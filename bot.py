#!/home/ultraxion/GNBot/GN/.venv/bin/activate
#!/usr/bin/ python3.8
# -*- coding: utf-8 -*-
"""Mains file for GNBot"""
# <<< Import's >>
from telebot.types import Message, InlineKeyboardButton, InlineKeyboardMarkup, InputMediaPhoto, InputMediaVideo
from telebot.types import LabeledPrice, PreCheckoutQuery, ShippingQuery
from pars import main, get_torrents1, get_torrents2, get_torrents3, get_instagram_videos, get_instagram_photos
from funcs import tr_w, rend_d, hi_r, log, clear_link, get_day, get_weather_emoji, sec_to_time, clear_date, get_lvl
from Config_GNBot.config import API, URLS, GNBot_ID, bot, PAYMENT_TOKEN, Admins
from youtube_search import YoutubeSearch
from urllib import parse, request, error
from pytube import YouTube, exceptions
from datetime import datetime as dt
from collections import defaultdict
from json import JSONDecodeError
import speech_recognition as sr
from pydub import AudioSegment
from threading import Thread
from threading import Timer
import wikipediaapi
import wikipedia
import tempfile
import requests
import ffmpeg
import random
import time
import db
import os
import re

# <<< End import's>>
log('Bot is successful running!', 'info')

# Turn on daily tasks
Thread(target=main, name='Parser').start()

# <<< Start >>>
@bot.message_handler(commands=['start'])
def start_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /start to see start menu
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        bot.send_chat_action(message.chat.id, 'typing')
        bot.send_message(message.chat.id, '–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π, –º–µ–Ω—è –∑–æ–≤—É—Ç <b>GNBot</b>üñ•\n'
                                          '–Ø –º–Ω–æ–≥–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∏ –º—É–ª—Ç–∏–º–µ–¥–∏–π–Ω—ã–π –±–æ—Çüëæ\n'
                                          '<b>–ü–æ–º–æ—â—å</b> <i>/help</i>', parse_mode='HTML')


# <<< End start >>>


# <<< Help >>>
@bot.message_handler(commands=['help'])
def help_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso::  Enter /help to see help info and contacts
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        bot.send_chat_action(message.chat.id, 'typing')
        bot.send_message(message.chat.id, '<b>–¢—É—Ç –¥–æ–ª–∂–Ω–∞ –±—ã–ª–∞ –±—ã—Ç—å –ø–æ–º–æ—â—å</b>üÜò, –Ω–æ –µ—ë —Ç—É—Ç –Ω–µ –±—É–¥–µ—Çüåö\n'
                                          '–°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥ –º–æ–∂–Ω–æ —É–≤–∏–¥–µ—Ç—å –≤–≤–µ–¥—è <b>\" </b>/<b> \"</b>\n'
                                          '–ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ –≤ –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö —á–∞—Ç–∞—Ö —Ç–∞–∫ –∏ –≤ –Ω–µ–±–æ–ª—å—à–∏—Ö –≥—Ä—É–ø–ø–∞—Öüò±'
                                          '–¢–∞–∫–∂–µ –±–æ—Ç –∏–º–µ–µ—Ç –≤–≤–µ—Å—Ç–∏ —É—á–µ—Ç –∫–∞—Ä–º—ã üòá\n'
                                          '–ê–¥–º–∏–Ω –∫–æ–º–∞–Ω–¥—ã (<b>!ban</b>, <b>!mute {<i>time</i>}</b>, <b>!kick</b>)\n'
                                          '–ë–æ—Ç–∞ –º–æ–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –ø–æ–¥ —Å–µ–±—è –ø–µ—Ä–µ–π–¥—è –≤ /settings üõ†\n'
                                          '–ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å —Ä–∞–∑—Ä–∞–±–æ—Ç–∫—É /donate üí∏'
                                          '–í—Å–µ —Å–≤–æ–∏ –≤–æ–ø—Ä–æ—Å—ã, –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∏–ª–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ –Ω–∞–π–¥–µ–º–Ω—ã–º '
                                          '–±–∞–≥–∞–º –∏ –æ—à–∏–±–∫–∞–º –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤–≤–µ–¥—è /feedback üÜò\n'
                                          '<b>–ü–æ—á—Ç–∞:</b> <i>ultra25813@gmail.com</i>', parse_mode='HTML')


# <<< End help >>>


# <<< Gif >>>
@bot.message_handler(commands=['gif'])
def gif_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /gif to get random Gif
    .. notes:: Api: https://api.giphy.com
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        bot.send_chat_action(message.chat.id, 'upload_video')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        while True:
            try:
                data = requests.get(API['Gif']['API'].replace('TAG', random.choice(API['Gif']['Tags']))).json()
                if hi_r(data['data']['rating']):
                    bot.send_document(message.chat.id, data['data']['images']['downsized_large']['url'])
                    break
            except Exception:
                continue



# <<< End gif >>>


# <<< QR Code >>>
qr_msg = defaultdict(Message)


@bot.message_handler(commands=['qrcode'])
def qrcode_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /qrcode to crate or reed QR Code
    .. notes:: Api: https://api.qrserver.com
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        keyboard = InlineKeyboardMarkup()
        keyboard.add(InlineKeyboardButton('–°–æ–∑–¥–∞—Ç—å', callback_data='Create_QRCode'),
                     InlineKeyboardButton('–°—á–∏—Ç–∞—Ç—å', callback_data='Read_QRCode'))
        qr_msg[message.chat.id] = bot.send_message(message.chat.id, '–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—éüßê', reply_markup=keyboard)


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^Create_QRCode$', call.data))
def create_qrcode(call) -> None:
    bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ —Å–æ–∑–¥–∞—Ç—å')
    bot.delete_message(qr_msg[call.message.chat.id].chat.id, qr_msg[call.message.chat.id].message_id)
    msg = bot.send_message(call.message.chat.id, '–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ URL‚úíÔ∏è')
    bot.register_next_step_handler(msg, send_qrcode)


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^Read_QRCode$', call.data))
def read_qrcode(call) -> None:
    bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ —Å—á–∏—Ç–∞—Ç—å')
    bot.delete_message(qr_msg[call.message.chat.id].chat.id, qr_msg[call.message.chat.id].message_id)
    msg = bot.send_message(call.message.chat.id, '–û—Ç–ø—Ä–∞–≤—å –º–Ω–µ QR Code –∏–ª–∏ –µ–≥–æ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—éüì∏')
    bot.register_next_step_handler(msg, read_text)


def read_text(message: Message) -> None:
    if message.content_type == 'photo':
        res = requests.post(API['QRCode']['Read'].replace('FILE', bot.get_file_url(message.photo[0].file_id))).json()
        if res[0]['symbol'][0]['data'] is not None:
            bot.send_message(message.chat.id, '<b>–ü–æ–ª—É—á–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç</b>üìù\n' + res[0]['symbol'][0]['data'], parse_mode='HTML')
        else:
            bot.send_message(message.chat.id, 'QR Code –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ωüòî')
    else:
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')


def send_qrcode(message: Message) -> None:
    bot.send_photo(message.chat.id, requests.get(API['QRCode']['Create'].replace('DATA', message.text.replace(' ', '+'))).content)


# <<< End QR Code >>>


# <<< Joke >>>
jokes_data = defaultdict(list)


@bot.message_handler(commands=['joke'])
def joke_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /joke to get random jock(18+)
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        if message.chat.id not in jokes_data or len(jokes_data[message.chat.id]) == 1:
            jokes_data[message.chat.id] = db.get_all('Joke')
        joke = jokes_data[message.chat.id].pop(random.randint(1, len(jokes_data[message.chat.id]) - 1))
        bot.send_chat_action(message.chat.id, 'typing')
        time.sleep(1.25)
        keyboard = InlineKeyboardMarkup()
        joke_msg = bot.send_message(message.chat.id, joke['setup'] + random.choice(['üßê', 'ü§®', 'ü§î']))
        if joke['panchline'] != 'False':
            time.sleep(3.5)
            keyboard.add(InlineKeyboardButton('–£–¥–∞–ª–∏—Ç—å', callback_data=f'del {joke_msg.message_id} {message.message_id}'))
            bot.edit_message_text(joke_msg.text + '\n\n' + joke['panchline'] + random.choice(['üåö', 'üòÖ', 'ü§´']),
                                  message.chat.id, joke_msg.message_id, reply_markup=keyboard)
        else:
            keyboard.add(InlineKeyboardButton('–£–¥–∞–ª–∏—Ç—å', callback_data=f'del {joke_msg.message_id} {message.message_id}'))
            bot.edit_message_text(joke_msg.text, message.chat.id, joke_msg.message_id, reply_markup=keyboard)


# <<< End joke >>>


# <<< Ogg to Mp3 >>>
msg_mp3ogg = defaultdict(Message)


@bot.message_handler(commands=['oggtomp3'])
def oggtomp3_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /oggtomp3 to convert your voice or ogg file to .mp3
    """
    global msg_mp3ogg
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        msg_mp3ogg[message.chat.id] = bot.send_message(message.chat.id, '–ó–∞–ø–∏—à–∏—Ç–µ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ—Å–æ–æ–±—â–µ–Ω–∏–µüéô')
        bot.register_next_step_handler(msg_mp3ogg[message.chat.id], set_name_mp3)


def set_name_mp3(message: Message) -> None:
    global msg_mp3ogg
    if message.content_type == 'voice':
        bot.delete_message(msg_mp3ogg[message.chat.id].chat.id, msg_mp3ogg[message.chat.id].message_id)
        bot.delete_message(message.chat.id, message.message_id)
        msg_mp3ogg[message.chat.id] = bot.send_message(message.chat.id, '–í–≤–µ–¥–∏—Ç–µ –∏–º—è —Ñ–∞–π–ª–∞‚úíÔ∏è')
        bot.register_next_step_handler(msg_mp3ogg[message.chat.id], send_mp3,  message.voice.file_id)
    else:
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')


def send_mp3(message: Message, file_id: int) -> None:
    if message.content_type != 'text':
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')
    else:
        bot.send_chat_action(message.chat.id, 'upload_voice')
        bot.delete_message(msg_mp3ogg[message.chat.id].chat.id, msg_mp3ogg[message.chat.id].message_id)
        bot.delete_message(message.chat.id, message.message_id)
        data = request.urlopen(bot.get_file_url(file_id)).read()
        with tempfile.NamedTemporaryFile(delete=False) as f:
            f.write(data)
        audio = AudioSegment.from_ogg(f.name)
        audio.export(f'{message.text}.mp3', format='mp3')
        bot.send_audio(message.chat.id, open(f'{message.text}.mp3', 'rb'))
        try:
            os.remove(os.path.join(os.path.abspath(os.path.dirname(__file__)), f'{message.text}' + '.mp3'))
        except (FileNotFoundError, NameError):
            log('Error! Can\'t remove file', 'warning')


# <<< End Ogg to Mp3 >>>


# <<< Meme >>>
meme_data = defaultdict(list)


@bot.message_handler(commands=['meme'])
def meme_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /meme to get random meme on rus or eng lang
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        bot.send_chat_action(message.chat.id, 'upload_photo')
        data = db.get_from(message.chat.id, 'Setting')
        if data['meme'] == 'Ru':
            if message.chat.id not in meme_data or len(meme_data[message.chat.id]) == 1:
                meme_data[message.chat.id] = db.get_all('Memes')
            while True:
                meme = meme_data[message.chat.id].pop(random.randint(1, len(meme_data[message.chat.id]) - 1))
                try:
                    msg = bot.send_photo(message.chat.id, meme['url'])
                    keyboard = InlineKeyboardMarkup()
                    if str(message.from_user.id) in Admins and message.chat.type == 'private':
                        keyboard.add(InlineKeyboardButton('–£–¥–∞–ª–∏—Ç—å',
                                                          callback_data=f'del_from_db {meme["id"]} {message.message_id}'
                                                                        f' {msg.message_id}'))
                    else:
                        keyboard.add(InlineKeyboardButton('–ó–∞–∫—Ä—ã—Ç—å',
                                                          callback_data=f'del {message.message_id} {msg.message_id}'))
                    bot.edit_message_media(chat_id=msg.chat.id, message_id=msg.message_id,
                                           media=InputMediaPhoto(msg.photo[-1].file_id),
                                           reply_markup=keyboard)
                    break
                except Exception:
                    db.del_meme(meme['id'])
                    continue
        else:
            meme = requests.get(API['API_Meme']).json()
            bot.send_photo(message.chat.id, meme['url'])


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^del_from_db\s.+\s.+\s.+$', call.data))
def del_meme_query(call):
    bot.answer_callback_query(call.id, '–£–¥–∞–ª–µ–Ω–æ')
    for msg_id in call.data.split()[2:]:
        bot.delete_message(call.message.chat.id, msg_id)
    db.del_meme(call.data.split()[1])
# <<< End meme >>>


# <<< Donate >>>
@bot.message_handler(commands=['donate'])
def donate_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /donate to see donate menu(not finished!)
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        bot.send_chat_action(message.chat.id, 'typing')
        if message.chat.type == 'private':
            bot.send_message(message.chat.id, '<b>–ö —Å–æ–∂–µ–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –¥–æ—Ä–∞–±–æ—Ç–∞–Ω–∞</b>üòî\n'
                                              '–ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å –ø—Ä–æ–µ–∫—Ç, '
                                              '–≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–µ–≤–µ—Å—Ç–∏ –∂–µ–ª–∞–µ–º—É—é —Å—É–º–º—É –Ω–∞ –∫–∞—Ä—Ç—É\n'
                                              '<b>MonoBank:</b> <i>5375 4141 1577 0850</i>\n'
                                              '<b>C —É–≤–∞–∂–µ–Ω–∏–µ–º <i>@Ultra_Xion</i></b>', parse_mode='HTML')
            # bot.send_message(message.chat.id, '–ó–¥–µ—Å—å –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∏ –¥–∞—Ç—å –º–æ—Ç–∏–≤–∞—Ü–∏—é '
            #                                   '–Ω–∞ –≤–Ω–µ—Å–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ñ—É–Ω—Ü–∏–æ–Ω–∞–ª–∞ –≤ <b>GNBot</b>\n'
            #                                   'C —É–≤–∞–∂–µ–Ω–∏–µ–º <i>@Ultra_Xion</i>', parse_mode='HTML')
            # if PAYMENT_TOKEN.split(':')[1] == 'LIVE':
            #     keyboard = InlineKeyboardMarkup(row_width=1)
            #     keyboard.add(InlineKeyboardButton('1 –≥—Ä–Ω', callback_data='1 UAH'),
            #                  InlineKeyboardButton('10 –≥—Ä–Ω', callback_data='10 UAH'),
            #                  InlineKeyboardButton('100 –≥—Ä–Ω', callback_data='100 UAH'),
            #                  InlineKeyboardButton('1000 –≥—Ä–Ω', callback_data='1000 UAH'),
            #                  InlineKeyboardButton('–°–≤–æ—è —Å—É–º–º–∞', callback_data='–°–≤–æ—è —Å—É–º–º–∞'))
            #     msg = bot.send_message(message.chat.id, '–°—É–º–º–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏üí∏', reply_markup=keyboard)
            #     time.sleep(20)
            #     bot.delete_message(msg.chat.id, msg.message_id)
        else:
            bot.send_message(message.chat.id, '–ö —Å–æ–∂–µ–ª–µ–Ω–∏—é –≤ –≥—Ä—É–ø–ø–µ —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞üòî\n'
                                              '–ß—Ç–æ –±—ã –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å –Ω–∞—Å –≤—ã –º–æ–∂–µ—Ç–µ –≤–æ—Å–ø–æ–ª–∑–æ–≤–∞—Ç—å—Å—è'
                                              '—ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–æ–π –≤ –ª–∏—á–Ω–æ–º —á–∞—Ç–µ —Å –±–æ—Ç–æ–º üí¢<b>@GNTMBot</b>üí¢',
                             parse_mode='HTML')


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^\d+\sUAH$', call.data) or call.data == '–°–≤–æ—è —Å—É–º–º–∞')
def donate_query(call):
    bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ ' + call.data)
    bot.edit_message_text(call.message.text, call.message.chat.id, call.message.message_id)
    if call.data == '–°–≤–æ—è —Å—É–º–º–∞':
        msg = bot.send_message(call.message.chat.id, '–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—Éüßê')
        bot.register_next_step_handler(msg, send_payment, 'UAH')
    else:
        send_payment(call.message, call.data)


def send_payment(message: Message, money) -> None:
    if money == 'UAH' and message.text.isdigit():
        local_money = message.text + ' ' + money
    else:
        local_money = money
    price = LabeledPrice('–ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å', amount=int(local_money.split()[0]) * 100)
    bot.send_invoice(message.chat.id, title='–ü–æ–¥–¥–µ—Ä–∂–∫–∞',
                     description='–ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ GNBot',
                     provider_token=PAYMENT_TOKEN, currency='uah',
                     photo_url=URLS['logo'],
                     photo_height=1494, photo_width=1295, photo_size=142,
                     is_flexible=False, prices=[price],
                     start_parameter='donate-programmer-gnbot',
                     invoice_payload='donate-is-done')


@bot.shipping_query_handler(func=lambda query: True)
def shipping(shipping_query: ShippingQuery):
    bot.answer_shipping_query(shipping_query.id, ok=True,
                              error_message='–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫üòî\n!'
                                            '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é —á—É—Ç—å –ø–æ–∑–∂–µ')


@bot.pre_checkout_query_handler(func=lambda query: True)
def process_pre_checkout_query(pre_checkout_query: PreCheckoutQuery):
    bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True,
                                    error_message="–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫üòî\n"
                                                  "–£–¥–µ–±–∏—Ç–µ–ª—å –≤ –ø—Ä–∞–≤–µ–ª—å–Ω–æ—Å—Ç–∏ –≤–≤–æ–¥–∏–º—ã—Ö –¥–∞–Ω–Ω—ã–µ "
                                                  "–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ –ø–∞—Ä—É –º–∏–Ω—É—Ç")


@bot.message_handler(content_types=['successful_payment'])
def process_successful_payment(message: Message) -> None:
    promo = message.successful_payment
    log(f'Successful_payment\nType: {promo.invoice_payload}\nSum: {promo.total_amount}{promo.currency}')
    bot.send_message(message.chat.id, f'–ü–ª–∞—Ç–µ–∂ –ø—Ä–æ—à–µ–ª —É—Å–ø–µ—à–Ω–æüòå\n'
                                      f'{message.successful_payment.total_amount // 100} '
                                      f'{message.successful_payment.currency} –±—ã–ª–∏ –Ω–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞ —Å–≤–µ—Ç\n'
                                      f'–ë–ª–∞–≥–æ–¥–∞—Ä–∏–º –≤–∞—Å –∑–∞ –ø–æ–¥–¥–µ—Ä–∂–∫—É –ø—Ä–æ–µ–∫—Ç–∞ü•≥')


# <<< End donate >>>


# <<< Casino rule >>>
@bot.message_handler(commands=['casino_rule'])
def casino_rule_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso::  Enter /casino_rule to see daily casino rules
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        keyboard = InlineKeyboardMarkup()
        msg = bot.send_message(message.chat.id, '–ó–∞–≥—Ä—É–∑–∫–∞...')
        keyboard.add(InlineKeyboardButton('–ó–∞–∫—Ä—ã—Ç—å', callback_data=f'del {message.message_id} {msg.message_id} '))
        bot.edit_message_text('<b><i>–ü—Ä–∞–≤–∏–ª–∞ –µ–∂–µ–Ω–µ–≤–Ω–æ–≥–æ –∫–∞–∑–∏–Ω–æ</i></b>\n'
                              '–ö–∞–∑–∏–Ω–æ –ø—Ä–æ–≤–æ–¥–∏—Ç—å—Å—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ <b>20:00</b> –∏ –¥–ª–∏—Ç—Å—è —Ä–æ–≤–Ω–æ <b>1 —á–∞—Å</b>\n'
                              '<b>1</b>üî¥\<b>1</b>‚ö´ - –ü—Ä–∏ –ø–æ–ª–Ω–æ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏ –ø–æ–±–µ–¥–Ω–æ–π —Å—Ç–∞–≤–∫–∏ –∏ –≤–∞—à–µ–π –¥–∞–µ—Ç –∫–æ–µ—Ñ–∏—Ü–∏–µ–Ω—Ç 1–∫27.\n'
                              '0Ô∏è‚É£(<b>Zero</b>)- –ü—Ä–∏ –≤—ã–ø–∞–¥–µ–Ω–∏–∏ –∑–µ—Ä–æ –≤–∞—à –∫–æ–µ—Ñ–µ—Ü–∏–µ–Ω—Ç —Å–æ—Å—Ç–∞–≤–∏—Ç —Ç–∞–∫ –∂–µ 1–∫27.\n'
                              '1Ô∏è‚É£(<b>–ù–µ —á–µ—Ç–Ω–æ–µ</b>)\\2Ô∏è‚É£(<b>–ß–µ—Ç–Ω–æ–µ</b>) - –ü—Ä–∏ –≤—ã–ø–∞–¥–µ–Ω–∏–∏ —á–µ—Ç–Ω–æ–≥–æ –∏–ª–∏ –Ω–µ —á–µ—Ç–Ω–æ–≥–æ –≤–∞—à –∫–æ–µ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–æ—Å—Ç–∞–≤–∏—Ç 1–∫1.\n'
                              'üî¥(<b>–ö—Ä–∞—Å–Ω–æ–µ</b>)\(‚ö´<b>–ß—ë—Ä–Ω–æ–µ</b>) - –ü—Ä–∏ –≤—ã–ø–∞–¥–µ–Ω–∏–∏ —á–µ—Ç–Ω–æ–≥–æ –∏–ª–∏ –Ω–µ —á–µ—Ç–Ω–æ–≥–æ –≤–∞—à –∫–æ–µ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–æ—Å—Ç–∞–≤–∏—Ç 1–∫1.\n'
                              '–ß—Ç–æ –±—ã –ø–æ–≤—ã—Å–∏—Ç—å —Å—Ç–∞–≤–∫—É –Ω–∞–∂–º–∏—Ç–∏ –Ω–∞ –∂–µ–ª–∞–µ–º—é –ø–æ–∑–∏—Ü–∏—é –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑.\n'
                              '–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Å—Ç–∞–≤–∫–∏ –≤—ã—Å—á–∏—Ç—ã–≤–∞—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—Å—Ö–æ–¥—è –∏–∑ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–∞—Ä–º—ã —Å—Ä–µ–¥–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≥—Ä—É–ø–ø—ã.',
                              message.chat.id, msg.message_id, reply_markup=keyboard, parse_mode='HTML')
# <<< End casino rule >>>


# <<< Weather >>>
weather_data = defaultdict(dict)
weather_msg = defaultdict(Message)
city_data = defaultdict(dict)
city_msg = defaultdict(Message)


@bot.message_handler(commands=['weather'])
def weather_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso::  Enter /weather and enter your city to see weather broadcast on 16th days
    .. notes:: Api:  https://api.weatherbit.io
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        city_msg[message.chat.id] = bot.send_message(message.chat.id, '–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥–æ—Ä–æ–¥–∞‚úíÔ∏è')
        bot.register_next_step_handler(city_msg[message.chat.id], show_weather)


def weather(message: Message, index: int) -> None:
    if not message.text.startswith('20'):
        bot.delete_message(message.chat.id, message.message_id)
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton(text="‚¨ÖÔ∏èÔ∏è", callback_data=f"weather_move_to {index - 1 if index > 0 else 'pass'}"),
        InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"weather_move_to "
                             f"{index + 1 if index < len(weather_data[message.chat.id]) - 1 else 'pass'}"))
    keyboard.add(InlineKeyboardButton('–ü–æ–≥–æ–¥–∞', url='https://' +
                                                    f'darksky.net/forecast/{city_data[message.chat.id]["lat"]},'
                                                    f'{city_data[message.chat.id]["lon"]}/us12/en'))
    keyboard.add(InlineKeyboardButton('–ó–∞–∫—Ä—ã—Ç—å', callback_data=f'del {weather_msg[message.chat.id].message_id}'))
    try:
        bot.edit_message_text(chat_id=weather_msg[message.chat.id].chat.id,
                              message_id=weather_msg[message.chat.id].message_id,
                              text=f"<i>{weather_data[message.chat.id][index]['valid_date']} "
                                   f"{get_day(weather_data[message.chat.id][index]['valid_date'])}</i>\n"
                                   f"<b>–ì–æ—Ä–æ–¥</b> {city_data[message.chat.id]['city_name']} "
                                   f"<b>{city_data[message.chat.id]['country_code']}</b>üè¢\n\n"
                                   f"<b>–ü–æ–≥–æ–¥–∞</b> {weather_data[message.chat.id][index]['weather']['description']}Ô∏è"
                                   f"{get_weather_emoji(str(weather_data[message.chat.id][index]['weather']['code']))}"
                                   f"\n<b>–¢–µ—Å–ø–µ—Ä–∞—Ç—É—Ä–∞</b> {weather_data[message.chat.id][index]['low_temp']} - "
                                   f"{weather_data[message.chat.id][index]['max_temp']}¬∞Cüå°\n"
                                   f"<b>–ü–æ –æ—â—É—à–µ–Ω–∏—é</b> {weather_data[message.chat.id][index]['app_min_temp']} - "
                                   f"{weather_data[message.chat.id][index]['app_max_temp']}¬∞Cüå°\n"
                                   f"<b>–û–±–ª–∞—á–Ω–æ—Å—Ç—å</b> {weather_data[message.chat.id][index]['clouds']}%‚òÅÔ∏è\n"
                                   f"<b>–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –æ—Å–∞–¥–∫–æ–≤</b> {weather_data[message.chat.id][index]['pop']}%‚òîÔ∏èÔ∏è\n"
                                   f"<b>–í–∏–¥–∏–º–æ—Å—Ç—å</b> {weather_data[message.chat.id][index]['vis']} –∫–ºüî≠\n"
                                   f"<b>–í–ª–∞–∂–Ω–æ—Å—Ç—å</b> {weather_data[message.chat.id][index]['rh']} %üíß\n"
                                   f"<b>–ê—Ç–º–æc. –¥–∞–≤–ª–µ–Ω–∏–µ</b> "
                                   f"{weather_data[message.chat.id][index]['pres']} –¥–∏–Ω¬∑—Å–º¬≤‚è≤\n"
                                   f"<b>–í–µ—Ç–µ—Ä</b> {weather_data[message.chat.id][index]['wind_cdir_full']} üß≠\n"
                                   f"<b>C–∫–æ—Ä–æ—Å—Ç—å –≤–µ—Ç—Ä–∞</b> "
                                   f"{float('{:.1f}'.format(weather_data[message.chat.id][index]['wind_spd']))}"
                                   f" –º\\—Åüí®\n",
                              reply_markup=keyboard, parse_mode='HTML')
    except KeyError:
        log('Key Error in weather', 'warning')
        bot.send_chat_action(message.chat.id, '‚õîÔ∏è')


def show_weather(message: Message) -> None:
    global weather_msg, city_data, weather_data
    if message.content_type != 'text':
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')
    else:
        bot.delete_message(city_msg[message.chat.id].chat.id, city_msg[message.chat.id].message_id)
        try:
            res = requests.get(API['API_Weather'].replace('CityName', message.text.title())).json()
        except JSONDecodeError:
            bot.send_message(message.chat.id, '–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –≤–∞—à –≥–æ—Ä–æ–¥üòî')
        else:
            if message.chat.id in weather_msg:
                bot.delete_message(weather_msg[message.chat.id].chat.id, weather_msg[message.chat.id].message_id)
            city_data[message.chat.id] = {'city_name': res['city_name'], 'country_code': res['country_code'],
                                          'lat': res['lat'], 'lon': res['lon']}
            weather_data[message.chat.id] = res['data']
            weather_msg[message.chat.id] = bot.send_message(message.chat.id, '–ó–∞–≥—Ä—É–∑–∫–∞...')
            weather(message, 0)


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^weather_move_to\s\d+$', call.data))
def weather_query(call):
    index = int(call.data.split()[1])
    if 0 <= index < len(weather_data[call.message.chat.id]):
        bot.answer_callback_query(call.id, f'–í—ã –≤—ã–±—Ä–∞–ª–∏ —Å—Ç—Ä.{index + 1}')
        weather(call.message, index)
    else:
        bot.answer_callback_query(call.id, '‚õîÔ∏è')


# <<< End weather >>>


# <<< Detect music >>>
detect_msg = defaultdict(Message)
data_detect = defaultdict(list)


@bot.message_handler(commands=['detect'])
def detect_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /detect to detect what song play now or you can humming song
    .. notes:: Api: https://api.audd.io
    """
    global detect_msg
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        bot.send_chat_action(message.chat.id, 'typing')
        keyboard = InlineKeyboardMarkup()
        keyboard.add(InlineKeyboardButton('–ó–∞–ø–∏—Å–∞—Ç—åüîä', callback_data='record'),
                     InlineKeyboardButton('–ù–∞–ø–µ—Ç—åüéô', callback_data='sing'))
        detect_msg[message.chat.id] = bot.send_message(message.chat.id, '–í—ã–±–µ—Ä–∏—Ç–µ —á—Ç–æ –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—åüßê',
                                                       reply_markup=keyboard)


@bot.callback_query_handler(func=lambda call: call.data == 'record' or call.data == 'sing')
def callback_query(call):
    bot.delete_message(detect_msg[call.message.chat.id].chat.id, detect_msg[call.message.chat.id].message_id)
    if call.data == 'record':
        bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ ' + '–ó–∞–ø–∏—Å–∞—Ç—å')
    else:
        bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ ' + '–ù–∞–ø–µ—Ç—å')
    msg = bot.send_message(call.message.chat.id, '–ó–∞–ø–∏—à–∏—Ç–µ —Ç–æ —á—Ç–æ –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—åüé§')
    bot.register_next_step_handler(msg, detect_music, call.data)


def detect_music(message: Message, type_r) -> None:
    global data_detect
    if message.content_type != 'voice':
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')
    else:
        API['AUDD_data']['url'] = bot.get_file_url(message.voice.file_id).replace('https://' + 'api.telegram.org',
                                                                                  'http://' + 'esc-ru.appspot.com/') \
                                  + '?host=api.telegram.org'
        if type_r == 'sing':
            data_detect[message.chat.id] = requests.post(API['AUDD'] + 'recognizeWithOffset/',
                                   data={'url': API['AUDD_data']['url'], 'api_token': API['AUDD_data']['api_token']}).json()
        else:
            data_detect[message.chat.id] = requests.post(API['AUDD'], data=API['AUDD_data']).json()
        if data_detect[message.chat.id]['status'] == 'success' and data_detect[message.chat.id]['result'] is not None:
            if type_r != 'sing':
                if data_detect[message.chat.id]['result']['deezer']:
                    keyboard = InlineKeyboardMarkup()
                    res = YoutubeUnlimitedSearch(f"{data_detect[message.chat.id]['result']['artist']} - "
                                                 f"{data_detect[message.chat.id]['result']['title']}",
                                                 max_results=1).get()
                    keyboard.add(InlineKeyboardButton('–¢–µ–∫—Å—Ç', callback_data=f"Lyric detect {str(data_detect[message.chat.id]['result']['deezer']['id'])}"),
                                InlineKeyboardButton('–ü–µ—Å–Ω—è', callback_data=res[0]['link']))
                    keyboard.add(InlineKeyboardButton('Dezeer', url=data_detect[message.chat.id]['result']['deezer']['link']))
                    bot.send_photo(message.chat.id, data_detect[message.chat.id]['result']['deezer']['artist']['picture_xl'],
                                   caption=f"{data_detect[message.chat.id]['result']['artist']} - {data_detect[message.chat.id]['result']['title']}üéµ",
                                   reply_markup=keyboard)
                else:
                    bot.send_message(message.chat.id, f"<b>{data_detect[message.chat.id]['result']['artist']}</b>"
                                                      f" - {data_detect[message.chat.id]['result']['title']}üéµ", parse_mode='HTML')
            else:
                msg = "<b>–†–µ–∑—É–ª—å—Ç–∞—Ç</b> "
                for i in data_detect[message.chat.id]['result']['list']:
                    msg += f"\n–°–æ–≤–ø–∞–¥–µ–Ω–∏–µ: <i>{i['score']}%</i>\n{i['artist']} - {i['title']}üéµ"
                bot.send_message(message.chat.id, msg, parse_mode='HTML')
        else:
            bot.send_message(message.chat.id, '–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–æ—Å—åüòî')


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'/watch\?v=\w+.+', call.data))
def callback_query(call):
    bot.send_chat_action(call.message.chat.id, 'upload_audio')
    for i in range(5):
        try:
            yt = YouTube('https://' + 'www.youtube.com/' + call.data.split()[0])
        except KeyError:
            continue
        else:
            bot.send_audio(call.message.chat.id,
                           open(yt.streams.filter(only_audio=True)[0].download(filename='file'), 'rb'),
                           title=yt.title, duration=yt.length, performer=yt.author,
                           caption=f'üéß {sec_to_time(yt.length)} '
                                   f'| {round(os.path.getsize("file.mp4") / 1000000, 1)} MB |'
                                   f' {yt.streams.filter(only_audio=True)[0].abr.replace("kbps", "")} Kbps')
            try:
                os.remove(os.path.join(os.path.abspath(os.path.dirname(__file__)), 'file' + '.mp4'))
            except (FileNotFoundError, NameError):
                log('Error! Can\'t remove file', 'warning')
            break


# <<< End detect music >>>


# <<< Music >>>
data_songs = defaultdict(list)
song_msg = defaultdict(Message)
msg_song = defaultdict(Message)


@bot.message_handler(commands=['music'])
def music_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /music to found music by artist or title song you can get song and them lyric
    .. notes:: Api: https://api.deezer.com/search & Lib: PyTube
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        bot.send_chat_action(message.chat.id, 'typing')
        keyboard = InlineKeyboardMarkup(row_width=2)
        keyboard.add(InlineKeyboardButton('–ü–æ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—éüé§', callback_data='artist?q='),
                     InlineKeyboardButton('–ü–æ —Ç—Ä–µ–∫—Éüéº', callback_data='track?q='))
        msg_song[message.chat.id] = bot.send_message(message.chat.id, '–ö–∞–∫ –±—É–¥–µ–º –∏—Å–∫–∞—Ç—å –º—É–∑—ã–∫—É?üéß', reply_markup=keyboard)


@bot.callback_query_handler(func=lambda call: call.data == 'artist?q=' or call.data == 'track?q=')
def callback_query(call):
    bot.delete_message(msg_song[call.message.chat.id].chat.id, msg_song[call.message.chat.id].message_id)
    if call.data == 'artist?q=':
        bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ –ø–æ–∏—Å–∫ –ø–æ –∞—Ä—Ç–∏—Å—Ç—É')
        msg = bot.send_message(call.message.chat.id, '–í–≤–µ–¥–∏—Ç–µ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—èüë§')
    else:
        bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ –ø–æ–∏—Å–∫ –ø–æ —Ç—Ä–µ–∫—É')
        msg = bot.send_message(call.message.chat.id, '–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞üñä')
    bot.register_next_step_handler(msg, get_song, call.data, msg.message_id)


def get_song(message: Message, choice: str, message_id: str) -> None:
    global data_songs, song_msg
    if message.content_type != 'text':
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')
    else:
        bot.delete_message(message.chat.id, message.message_id)
        bot.delete_message(message.chat.id, message_id)
        res = requests.get(API['API_Deezer'] + choice + message.text.replace(' ', '+')).json()
        try:
            if res['data']:
                if choice == 'artist?q=':
                    songs = requests.get(res['data'][0]['tracklist'].replace('limit=50', 'limit=100')).json()
                    if songs['data']:
                        data_songs[message.chat.id] = [
                            {'id': song['id'], 'title': song['title'], 'name': song['contributors'][0]['name'],
                             'link': song['link'], 'preview': song['preview'], 'duration': song['duration']}
                            for song in songs['data']]
                        create_data_song(message)
                        if data_songs[message.chat.id]:
                            if message.chat.id in song_msg:
                                bot.delete_message(song_msg[message.chat.id].chat.id,
                                                   song_msg[message.chat.id].message_id)
                            song_msg[message.chat.id] = bot.send_photo(message.chat.id, res['data'][0]['picture_xl'],
                                                                       reply_markup=inline_keyboard(message, 0))
                        else:
                            raise FileExistsError
                elif choice == 'track?q=':
                    data_songs[message.chat.id] = [{'id': i['id'], 'title': i['title'], 'name': i['artist']['name'],
                                                    'link': i['link'], 'preview': i['preview'],
                                                    'duration': i['duration']} for i in res['data']]
                    create_data_song(message)
                    if data_songs[message.chat.id]:
                        if message.chat.id in song_msg:
                            bot.delete_message(song_msg[message.chat.id].chat.id, song_msg[message.chat.id].message_id)
                        song_msg[message.chat.id] = bot.send_message(message.chat.id,
                                                                     f'–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞ <b>{message.text}</b>üîé',
                                                                     parse_mode='HTML',
                                                                     reply_markup=inline_keyboard(message, 0))
                    else:
                        raise FileExistsError
                else:
                    raise FileExistsError
            else:
                raise FileExistsError
        except FileExistsError:
            bot.send_message(message.chat.id, '–ö —Å–æ–∂–µ–ª–µ–Ω–∏—è –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–æ—Å—åüòî')


def create_data_song(message: Message) -> None:
    global data_songs
    list_music, buf = [], []
    for i, en in enumerate(data_songs[message.chat.id], 1):
        buf.append(en)
        if i % 5 == 0:
            list_music.append(buf.copy())
            buf.clear()
    if buf:
        list_music.append(buf.copy())
    data_songs[message.chat.id] = list_music.copy()


def inline_keyboard(message: Message, some_index) -> InlineKeyboardMarkup:  # Navigation for music
    some_keyboard = InlineKeyboardMarkup()
    try:
        for songs in data_songs[message.chat.id][some_index]:
            some_keyboard.add(InlineKeyboardButton(f"{songs['name']} - {songs['title']}",
                                                   callback_data=f"ID: {songs['id']}"))
        some_keyboard.add(
            InlineKeyboardButton(text="‚¨ÖÔ∏èÔ∏è", callback_data=f"music_move_to {some_index - 1 if some_index > 0 else 'pass'}"),
            InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"music_move_to "
                                 f"{some_index + 1 if some_index < len(data_songs[message.chat.id]) - 1 else 'pass'}"))
        return some_keyboard
    except KeyError:
        log('Key Error in music', 'warning')


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^music_move_to\s\d$', call.data))
def callback_query(call):
    index = int(call.data.split()[1])
    if 0 <= index < len(data_songs[call.message.chat.id]):
        bot.answer_callback_query(call.id, f'–í—ã –≤—ã–±—Ä–∞–ª–∏ —Å—Ç—Ä.{index + 1}')
        if call.message.content_type == 'photo':
            bot.edit_message_media(chat_id=call.message.chat.id, message_id=call.message.message_id,
                                   media=InputMediaPhoto(call.message.photo[-1].file_id),
                                   reply_markup=inline_keyboard(call.message, index))
        else:
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id,
                                  text=call.message.text,
                                  reply_markup=inline_keyboard(call.message, index))
    else:
        bot.answer_callback_query(call.id, '‚õîÔ∏è')


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^ID:\s?\d+$', call.data))
def callback_query(call):
    song_id = call.data.replace('ID: ', '')
    for song in data_songs[call.message.chat.id]:
        for item in song:
            if item['id'] == int(song_id):
                for i in range(5):
                    try:
                        res = YoutubeSearch(f'{item["name"]} - {item["title"]}', max_results=1).to_dict()
                        yt = YouTube('https://' + 'www.youtube.com' + res[0]['url_suffix'])
                    except (KeyError, IndexError) as exp:
                        print(exp)
                        continue
                    else:
                        bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ ' + item["name"] + ' - ' + item["title"])
                        bot.send_chat_action(call.message.chat.id, 'upload_audio')
                        keyboard = InlineKeyboardMarkup(row_width=2)
                        keyboard.add(InlineKeyboardButton('–¢–µ–∫—Å—Ç', callback_data=f'Lyric music {str(song_id)}'),
                                     InlineKeyboardButton('Dezeer', url=item['link']))
                        bot.send_audio(call.message.chat.id, audio=open(yt.streams.filter(
                            only_audio=True)[0].download(filename='file'), 'rb'),
                                       reply_markup=keyboard, performer=item['name'],
                                       title=item['title'], duration=item['duration'],
                                       caption=f'üéß {sec_to_time(yt.length)} '
                                               f'| {round(os.path.getsize("file.mp4") / 1000000, 1)} MB |'
                                               f' {yt.streams.filter(only_audio=True)[0].abr.replace("kbps", "")}'
                                               f' Kbps')
                        try:
                            os.remove(os.path.join(os.path.abspath(os.path.dirname(__file__)), 'file' + '.mp4'))
                        except (FileNotFoundError, NameError):
                            log('Error! Can\'t remove file', 'warning')
                        break
                else:
                    bot.answer_callback_query(call.id, '–í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç —Ç—Ä–µ–∫ –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ωüòî')
    else:
        bot.answer_callback_query(call.id, '–°–ø–∏—Å–æ–∫ –ø–µ—Å–µ–Ω –ø—É—Å—Ç, –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æüòî')



# <<< End music >>>


# <<< Lyric >>>
@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^Lyric\s\w+\s\d+$', call.data))
def callback_query(call):
    """
   :param call
   :return: None
   .. seealso:: Get lyric from song
   .. notes:: Api: https://api.audd.io/
   """
    type_lyric, song_id = call.data.split()[1:]
    keyboard = InlineKeyboardMarkup()
    res = None
    if type_lyric == 'music':
        for song in data_songs[call.message.chat.id]:
            for item in song:
                if item['id'] == int(song_id):
                    bot.answer_callback_query(call.id, f'–¢–µ–∫—Å—Ç {item["name"]} - {item["title"]}')
                    res = requests.get(API['AUDD'] + 'findLyrics/?q=' + item['name'] + ' ' + item['title']).json()
    elif type_lyric == 'detect':
        res = requests.get(API['AUDD'] + 'findLyrics/?q=' + data_detect[call.message.chat.id]['result']['artist'] + ' ' +
                           data_detect[call.message.chat.id]['result']['title']).json()
    if res['status'] == 'success' and res['result'] is not None:
        msg = bot.reply_to(call.message, res['result'][0]['lyrics'])
        keyboard.add(InlineKeyboardButton('–£–¥–∞–ª–∏—Ç—å', callback_data=f'del {msg.message_id}'))
        bot.edit_message_text(chat_id=msg.chat.id, message_id=msg.message_id,
                              text=msg.text,
                              reply_markup=keyboard)

# <<< End lyric >>>


# <<< Path_news >>>

@bot.message_handler(commands=['path_news'])
def path_news_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /path_news to send news about path to all users
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        log(message, 'info')
        if str(message.from_user.id) in Admins:
            msg = bot.send_message(message.chat.id, '–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–ø–∏—Å–æ–∫ –∏–∑–º–µ–Ω–µ–Ω–∏–πüóí')
            bot.register_next_step_handler(msg, send_path_news)
        else:
            bot.send_message(message.chat.id, '–û–ø—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–∏üòî')

def send_path_news(message: Message) -> None:
    text = '<b>Path Notesüóí</b>\n' + ''.join([f'‚Ä¢ {info}\n' for info in message.text.split('\n')])
    for chat in db.get_id_from_where('Setting', 'path_news', 'On'):
        if chat['id'] not in Admins:
            keyboard = InlineKeyboardMarkup()
            try:
                msg = bot.send_message(chat['id'], text)
                keyboard.add(InlineKeyboardButton('–ó–∞–∫—Ä—ã—Ç—å', callback_data=f'del {msg.message_id}'))
                bot.edit_message_text(text, chat['id'], msg.message_id, parse_mode='HTML', reply_markup=keyboard)
            except Exception:
                log('Can\'t send path news', 'warning')
    bot.send_message(message.chat.id, '–†–∞—Å—Å—ã–ª–∫–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æüòé')

# <<< End path_news >>>


# <<< Loli&Hentai&Girl >>>
@bot.message_handler(commands=['loli'])
@bot.message_handler(commands=['girl'])
@bot.message_handler(commands=['hentai'])
def forbidden_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /{command} to get random hentai(18+) or loli(18+), or girl(18+). Access is limited
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        log(message, 'info')
        keyboard = InlineKeyboardMarkup()
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        setting = db.get_from(message.chat.id, 'Setting')
        if setting['censure'] == 'Off':
            if db.get_user_karma(message.from_user.id) > 9 or message.chat.type == 'private':
                if message.chat.type != 'private':
                    db.change_karma(message.from_user.id, '-', 10)
                while True:
                    if message.text.lower() in ['/loli', '–ª–æ–ª–∏', 'loli', '/loli@gntmbot', '/loli@pineapple_test_bot']:
                        data = db.get_forbidden('loli')
                    elif message.text.lower() in ['/hentai', '—Ö–µ–Ω—Ç–∞–π', 'hentai', '/hentai@gntmbot', '/hentai@pineapple_test_bot']:
                        data = db.get_forbidden('hentai')
                    else:
                        data = db.get_forbidden('girls')
                    try:
                        if requests.get(data).ok:
                            msg = bot.send_photo(message.chat.id, data)
                            keyboard.add((InlineKeyboardButton('–£–¥–∞–ª–∏—Ç—å',
                                                               callback_data=f'del {msg.message_id} {message.message_id}')))
                            bot.edit_message_media(chat_id=msg.chat.id, message_id=msg.message_id,
                                                   media=InputMediaPhoto(msg.photo[-1].file_id),
                                                   reply_markup=keyboard)
                            break
                    except Exception:
                        continue
            else:
                bot.send_message(message.chat.id, '–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–∞—Ä–º—ãüòî')
        else:
            bot.send_message(message.chat.id, '–¶–µ–Ω–∑—É—Ä–∞ –≤–∫–ª—é—á–µ–Ω–∞, —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞üòî\n–û—Ç–∫–ª—é—á–∏—Ç—å —Ü–µ–Ω–∑—É—Ä—É –º–æ–∂–Ω–æ <i>/settings</i>',
                            parse_mode='HTML')

# <<< End loli&hentai&girl >>>


# <<< News >>>
news = defaultdict(list)
news_msg = defaultdict(Message)


@bot.message_handler(commands=['news'])
def news_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /news to get news in 8th different categories and links on themd
    .. notes:: Api: https://newsapi.org
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        keyboard = InlineKeyboardMarkup(row_width=2)
        keyboard.add(InlineKeyboardButton('–¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏', callback_data='News technology'),
                     InlineKeyboardButton('–ù–∞—É–∫–∞', callback_data='News science'))
        keyboard.add(InlineKeyboardButton('–ó–¥–æ—Ä–æ–≤—å–µ', callback_data='News health'),
                     InlineKeyboardButton('–û–±—â–∏–µ', callback_data='News general'))
        keyboard.add(InlineKeyboardButton('–†–∞–∑–≤–ª–µ—á–µ–Ω–∏—è', callback_data='News entertainment'),
                     InlineKeyboardButton('–°–ø–æ—Ä—Ç', callback_data='News sports'))
        bot.send_message(message.chat.id, '<b>–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–æ–≤–æ—Å—Ç–µ–π</b>', reply_markup=keyboard, parse_mode='HTML')


def main_news(message: Message, news_type: str) -> None:
    global news_msg, news
    setting = db.get_from(message.chat.id, 'Setting')
    api = API['News']['URL'].replace('Country', f'{"ua" if setting["news"] == "Ua" else "ru" if setting["news"] == "Ru" else "us"}')
    res = requests.get(api.replace('Method', f'{news_type}') + API['News']['Api_Key']).json()
    if res['status'] == 'ok':
        news[message.chat.id] = [{'title': i['title'], 'description': i['description'],
                                  'url': i['url'], 'image': i['urlToImage'], 'published': i['publishedAt']} for i in
                                 res['articles']]
    for i in news[message.chat.id]:
        if i['image'] is not None:
            i['title'] = clear_link(i['title'])
            if i['description'] is not None:
                i['description'] = clear_link(i['description'])
    news_msg[message.chat.id] = bot.send_photo(message.chat.id, API['News']['image'])
    send_news(message, 0)


def send_news(message: Message, index: int) -> None:
    keyboard2 = InlineKeyboardMarkup()
    keyboard2.add(
        InlineKeyboardButton(text="‚¨ÖÔ∏èÔ∏è", callback_data=f"news_move_to {index - 1 if index > 0 else 'pass'}"),
        InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"news_move_to "
                                                      f"{index + 1 if index < len(news[message.chat.id]) - 1 else 'pass'}"))
    if news[message.chat.id][index]['title'] == news[message.chat.id][index + 1]['title']:
        news[message.chat.id].pop(index)
        send_news(message, index + 1)
        return
    try:
        if requests.get(news[message.chat.id][index]['url']).ok:
            keyboard2.add(InlineKeyboardButton('–ß–∏—Ç–∞—Ç—å', url=news[message.chat.id][index]['url']))
    except (requests.exceptions.ConnectionError, requests.exceptions.MissingSchema):
        news[message.chat.id].pop(index)
        send_news(message, index + 1)
        return
    except IndexError:
        log('Index Error in news url', 'warning')
    if news[message.chat.id][index]['image'] is None or news[message.chat.id][index]['image'] == '':
        if news[message.chat.id][index]['description'] is not None:
            bot.edit_message_media(chat_id=news_msg[message.chat.id].chat.id,
                                   message_id=news_msg[message.chat.id].message_id,
                                   media=InputMediaPhoto(API['News']['image'],
                                                         caption=f"<b>{news[message.chat.id][index]['title']}</b>"
                                                                 f"\n\n{news[message.chat.id][index]['description']}"
                                                                 f"\n\n<i>{clear_date(news[message.chat.id][index]['published'])}</i>"
                                                                 f"    <b>{index + 1}/{len(news[message.chat.id])}</b>—Å—Ç—Ä.",
                                                         parse_mode='HTML'), reply_markup=keyboard2)
        else:
            bot.edit_message_media(chat_id=news_msg[message.chat.id].chat.id,
                                   message_id=news_msg[message.chat.id].message_id,
                                   media=InputMediaPhoto(API['News']['image'],
                                                         caption=f"<b>{news[message.chat.id][index]['title']}</b>\n<i>\n"
                                                                 f"{clear_date(news[message.chat.id][index]['published'])}</i>"
                                                                 f"    <b>{index + 1}/{len(news[message.chat.id])}</b>—Å—Ç—Ä.",
                                                         parse_mode='HTML'), reply_markup=keyboard2)
    else:
        try:
            if requests.get(news[message.chat.id][index]['image']).ok:
                req = request.Request(news[message.chat.id][index]['image'], method='HEAD')
                f = request.urlopen(req)
                if f.headers['Content-Length'] is not None:
                    if int(f.headers['Content-Length']) > 5242880:
                        raise error.URLError
        except (requests.exceptions.ConnectionError, requests.exceptions.MissingSchema, error.URLError,
                UnicodeEncodeError):
            news[message.chat.id].pop(index)
            send_news(message, index + 1)
            return
        except IndexError as exp:
            log(f'Index Error in news\n{exp}', 'warning')
        try:
            if news[message.chat.id][index]['description'] is not None:
                bot.edit_message_media(chat_id=news_msg[message.chat.id].chat.id,
                                       message_id=news_msg[message.chat.id].message_id,
                                       media=InputMediaPhoto(news[message.chat.id][index]['image'],
                                       caption=f"<b>{news[message.chat.id][index]['title']}</b>"
                                               f"\n\n{news[message.chat.id][index]['description']}"
                                               f"\n\n<i>{clear_date(news[message.chat.id][index]['published'])}</i>"
                                               f"    <b>{index + 1}/{len(news[message.chat.id])}</b>—Å—Ç—Ä.",
                                       parse_mode='HTML'), reply_markup=keyboard2)
            else:
                bot.edit_message_media(chat_id=news_msg[message.chat.id].chat.id,
                                       message_id=news_msg[message.chat.id].message_id,
                                       media=InputMediaPhoto(news[message.chat.id][index]['image'],
                                       caption=f"<b>{news[message.chat.id][index]['title']}</b>\n<i>"
                                               f"{clear_date(news[message.chat.id][index]['published'])}</i>"
                                               f"    <b>{index + 1}/{len(news[message.chat.id])}</b>—Å—Ç—Ä.",
                                       parse_mode='HTML'), reply_markup=keyboard2)
        except Exception:
            news[message.chat.id].pop(index)
            send_news(message, index + 1)


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^News\s?\w+$', call.data))
def choice_news_query(call):
    bot.answer_callback_query(call.id, f'–í—ã –≤—ã–±—Ä–∞–ª–∏ —Å—Ç—Ä.1')
    bot.delete_message(call.message.chat.id, call.message.message_id)
    if call.message.chat.id in news_msg:
        bot.delete_message(news_msg[call.message.chat.id].chat.id, news_msg[call.message.chat.id].message_id)
    main_news(call.message, call.data.split()[1])



@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^news_move_to\s\d+$', call.data))
def next_news_query(call):
    index = int(call.data.split()[1])
    if 0 <= index < len(news[call.message.chat.id]):
        bot.answer_callback_query(call.id, f'–í—ã –≤—ã–±—Ä–∞–ª–∏ —Å—Ç—Ä.{index + 1}')
        send_news(call.message, index)
        return
    bot.answer_callback_query(call.id, '‚õîÔ∏è')


# <<< End news >>>


# <<< YouTube >>>
@bot.message_handler(commands=['youtube'])
def youtube_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso::  Enter /youtube to get audio or video from youtube link
    .. notes:: Lib: PyTube
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        keyboard = InlineKeyboardMarkup()
        keyboard.add(InlineKeyboardButton('–í–∏–¥–µ–æüì∫', callback_data='Video'),
                     InlineKeyboardButton('–ê—É–¥–∏–æüéß', callback_data='Audio'))
        bot.send_message(message.chat.id, '–í—ã–±–µ—Ä–∏—Ç–µ —á—Ç–æ –≤–∞–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—åüßê', reply_markup=keyboard)


@bot.callback_query_handler(func=lambda call: call.data == 'Audio' or call.data == 'Video')
def youtube_call(call):
    bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ ' + tr_w(call.data))
    bot.delete_message(call.message.chat.id, call.message.message_id)
    link = bot.send_message(call.message.chat.id, '–û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–µ–æüîó')
    bot.register_next_step_handler(link, send_audio, call.data, link.message_id)


def send_audio(message: Message, method: str, message_id: int) -> None:
    if message.content_type != 'text':
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')
    else:
        if re.fullmatch(r'^https?://.*[\r\n]*$', message.text):
            keyboard = InlineKeyboardMarkup()
            keyboard.add(InlineKeyboardButton('YouTube', url=message.text))
            for i in range(5):
                try:
                    yt = YouTube(message.text)
                except error.HTTPError:
                    bot.send_message(message.chat.id, '–ù–µ –º–æ–≥—É –Ω–∞–π—Ç–∏ —Ñ–∞–π–ªüòî')
                    break
                except exceptions.RegexMatchError:
                    bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—Å—ã–ª–∫–∏üòî')
                    break
                except KeyError:
                    continue
                else:
                    if method == 'Audio':
                        bot.send_chat_action(message.chat.id, 'upload_audio')
                        yt.streams.filter(only_audio=True)[0].download(filename='file')
                        if round(os.path.getsize("file.mp4") / 1000000, 1) < 50:
                            bot.send_audio(message.chat.id, open('file.mp4', 'rb'),
                                           reply_markup=keyboard, duration=yt.length, title=yt.title, performer=yt.author,
                                           caption=f'üéß {sec_to_time(yt.length)} '
                                                   f'| {round(os.path.getsize("file.mp4") / 1000000, 1)} MB |'
                                                   f' {yt.streams.filter(only_audio=True)[0].abr.replace("kbps", "")} Kbps')
                            bot.delete_message(message.chat.id, message.message_id)
                            bot.delete_message(message.chat.id, message_id)
                        else:
                            bot.send_message(message.chat.id, '–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–πüòî')
                        try:
                            os.remove(os.path.join(os.path.abspath(os.path.dirname(__file__)), 'file' + '.mp4'))
                        except (FileNotFoundError, NameError):
                            log('Error! Can\'t remove file', 'warning')
                        break
                    else:
                        try:
                            resolution = '480p'
                            yt.streams.filter(res="480p").order_by('resolution').desc()[0].download(filename='video')
                        except (error.HTTPError, IndexError):
                            try:
                                resolution = '320p'
                                yt.streams.filter(res="320p").order_by('resolution').desc()[0].download(filename='video')
                            except (error.HTTPError, IndexError):
                                try:
                                    resolution = '240p'
                                    yt.streams.filter(res="240p").order_by('resolution').desc()[0].download(filename='video')
                                except (error.HTTPError, IndexError):
                                    try:
                                        resolution = '144p'
                                        yt.streams.filter(res="144p").order_by('resolution').desc()[0].download(filename='video')
                                    except error.HTTPError:
                                        bot.send_message(message.chat.id, '–ù–µ –º–æ–≥—É –Ω–∞–π—Ç–∏ —Ñ–∞–π–ªüòî')
                                    except IndexError:
                                        bot.send_message(message.chat.id, '–†–∞–∑–º–µ—Ä –≤–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–πüòî')
                                    else:
                                        load_video(message, yt, keyboard, resolution)
                                        bot.delete_message(message.chat.id, message_id)
                                        break
                                else:
                                    load_video(message, yt, keyboard, resolution)
                                    bot.delete_message(message.chat.id, message_id)
                                    break
                            else:
                                load_video(message, yt, keyboard, resolution)
                                bot.delete_message(message.chat.id, message_id)
                                break
                        else:
                            load_video(message, yt, keyboard, resolution)
                            bot.delete_message(message.chat.id, message_id)
                            break
        else:
            bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')


def load_video(message: Message, yt, keyboard, resolution):
    yt.streams.filter(only_audio=True)[0].download(filename='audio')
    ffmpeg_work = Thread(target=ffmpeg_run, name='ffmpeg_work')
    msg = bot.send_message(message.chat.id, '–ó–∞–≥—Ä—É–∑–∫–∞...')
    ffmpeg_work.start()
    ffmpeg_work.join()
    time.sleep(1)
    if round(os.path.getsize("file.mp4") / 1000000, 1) < 50:
        bot.delete_message(message.chat.id, message.message_id)
        bot.delete_message(msg.chat.id, msg.message_id)
        bot.send_video(message.chat.id, open('file.mp4', 'rb'),
                       duration=yt.length, reply_markup=keyboard,
                       caption=f'üéß {sec_to_time(yt.length)} '
                               f'| {round(os.path.getsize("file.mp4") / 1000000, 1)} MB '
                               f'| {yt.streams.filter(only_audio=True)[0].abr.replace("kbps", "")} Kbps '
                               f'| {resolution}')
    else:
        bot.send_message(message.chat.id, '–î–∞–Ω–æ–µ –≤–∏–¥–µ–æ –∏–º–µ–µ—Ç —Å–ª–∏–≥–∫–æ–º –±–æ–ª—å—à–æ–π –æ–±—ä–µ–º,'
                                          ' –º–æ–π –ª–∏–º–∏—Ç 50–ú–ëüòî')
    try:
        for i in os.listdir(os.path.dirname(__file__)):
            if i.startswith('video') or i.startswith('audio') or i.startswith('file'):
                os.remove(os.path.join(os.path.abspath(os.path.dirname(__file__)), i))
    except (FileNotFoundError, NameError):
        log('Error! Can\'t remove file', 'warning')


def ffmpeg_run():
    input_audio, input_video = None, None
    for i in os.listdir(os.path.dirname(__file__)):
        if i.startswith('audio'):
            input_audio = ffmpeg.input(i)
        elif i.startswith('video'):
            input_video = ffmpeg.input(i)
    input_video = ffmpeg.filter(input_video, 'fps', fps=25, round='up')
    ffmpeg.output(input_video, input_audio, "file.mp4", preset='faster',
                  vcodec='libx264', acodec='mp3', **{'qscale:v': 10}).run(overwrite_output=True)


# <<< End YouTube >>>


# <<< Instagram >>>
msg_instagram = defaultdict(Message)


@bot.message_handler(commands=['instagram'])
def instagram_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso::  Enter /instagram to get photo(s) or video(s) from instagram link
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        keyboard = InlineKeyboardMarkup()
        keyboard.add(InlineKeyboardButton('–§–æ—Ç–æüì∑', callback_data='Instagram photo'),
                     InlineKeyboardButton('–í–∏–¥–µ–æüìπ', callback_data='Instagram video'))
        msg_instagram[message.chat.id] = bot.send_message(message.chat.id, '<b>–ß—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å</b>',
                                                          parse_mode='HTML', reply_markup=keyboard)


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'Instagram\s\w+', call.data))
def callback_query(call):
    bot.delete_message(msg_instagram[call.message.chat.id].chat.id, msg_instagram[call.message.chat.id].message_id)
    msg = bot.send_message(call.message.chat.id, '–û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å—Å—ã–ª–∫—É‚úíÔ∏è')
    if call.data.split()[1] == 'video':
        bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ –≤–∏–¥–µ–æ')
        bot.register_next_step_handler(msg, get_instagram_video, msg.message_id)
    else:
        bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ —Ñ–æ—Ç–æ')
        bot.register_next_step_handler(msg, get_instagram_photo, msg.message_id)


def get_instagram_video(message: Message, message_id: str) -> None:
    if message.content_type != 'text':
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')
    else:
        if re.match(r'^https?://(www.)?instagram.com/\w+/.+', message.text):
            url = re.search(r'^https?://(www.)?instagram.com/\w+/.+/', message.text).group(0)
            bot.delete_message(message.chat.id, message_id)
            bot.delete_message(message.chat.id, message.message_id)
            if url is not None:
                try:
                    data = get_instagram_videos(url)
                except JSONDecodeError:
                    bot.send_message(message.chat.id, '–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ä–∞–±–æ—Ç–∞ –∑–∞–∫—Ä—ã—Ç—ã–º–∏ –∞–∫–∫–∞—É–Ω—Ç–∞–º–∏üòî')
                else:
                    if data:
                        bot.send_chat_action(message.chat.id, 'upload_video')
                        if len(data) == 1:
                            if data[0]['is_video'] is True:
                                try:
                                    keyboard = InlineKeyboardMarkup()
                                    keyboard.add(InlineKeyboardButton('Instagram', url=url))
                                    bot.send_video(message.chat.id, data[0]['url'], reply_markup=keyboard)
                                except Exception:
                                    bot.send_message(message.chat.id, '–†–∞–∑–º–µ—Ä –≤–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–πüòî')
                            else:
                                bot.send_message(message.chat.id, '–ü–æ —Å—Å—ã–ª–∫–µ –Ω–µ—Ç –≤–∏–¥–µ–æüòî')
                        else:
                            list_data = []
                            for i in data:
                                if i['is_video'] is True:
                                    list_data.append(InputMediaVideo(i['url']))
                                else:
                                    list_data.append(InputMediaPhoto(i['url']))
                            try:
                                bot.send_media_group(message.chat.id, list_data)
                            except Exception:
                                bot.send_message(message.chat.id, '–†–∞–∑–º–µ—Ä –º–µ–¥–∏–∞ –¥–∞–Ω–Ω—ã—Ö —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–πüòî')
                    else:
                        bot.send_message(message.chat.id, '–ü–æ —Å—Å—ã–ª–∫–µ –Ω–∏—á–µ–≥–æ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æüòî')
            else:
                bot.send_message(message.chat.id, '–ù–µ —Å–º–æ–≥ –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µüòî')
        else:
            bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—Å—ã–ª–∫–∏üòî')


def get_instagram_photo(message: Message, message_id: str) -> None:
    bot.send_chat_action(message.chat.id, 'upload_photo')
    if re.match(r'^https?://(www.)?instagram.com/\w+/.+', message.text):
        url = re.search(r'^https?://(www.)?instagram.com/\w+/.+/', message.text).group(0)
        bot.delete_message(message.chat.id, message_id)
        bot.delete_message(message.chat.id, message.message_id)
        if url is not None:
            try:
                data = get_instagram_photos(url)
            except JSONDecodeError:
                bot.send_message(message.chat.id, '–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ä–∞–±–æ—Ç–∞ –∑–∞–∫—Ä—ã—Ç—ã–º–∏ –∞–∫–∫–∞—É–Ω—Ç–∞–º–∏üòî')
            else:
                if data:
                    if len(data) == 1:
                        keyboard = InlineKeyboardMarkup()
                        keyboard.add(InlineKeyboardButton('Instagram', url=url))
                        bot.send_photo(message.chat.id, data[0], reply_markup=keyboard)
                    else:
                        bot.send_media_group(message.chat.id, [InputMediaPhoto(photo) for photo in data])
                else:
                    bot.send_message(message.chat.id, '–ü–æ –¥–∞–Ω–Ω–æ–π —Å—Å—ã–ª–∫–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æüòî')
        else:
            bot.send_message(message.chat.id, '–ù–µ —Å–º–æ–≥ –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µüòî')
    else:
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—Å—ã–ª–∫–∏üòî')


# <<< End Instagram >>>


# <<< Torrent >>>
data_torrents = defaultdict(dict)
torrent_msg = defaultdict(Message)
search_msg = defaultdict(str)
tracker = defaultdict(str)
search = defaultdict(Message)


@bot.message_handler(commands=['torrent'])
def torrents_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /torrent to search torrents on Rutor.info, GTorrent.ru or Gamestracker.org
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        keyboard = InlineKeyboardMarkup()
        keyboard.add(InlineKeyboardButton('Rutor.infoüá∑üá∫', callback_data='Rutor.info'))
        keyboard.add(InlineKeyboardButton('GTorrent.ruüá∑üá∫', callback_data='GTorrent.ru'))
        keyboard.add(InlineKeyboardButton('Gamestracker.orgüá∑üá∫', callback_data='Gamestracker.org'))
        search[message.chat.id] = bot.send_message(message.chat.id, '–í—ã–±–µ—Ä–∏—Ç–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ÉÔ∏è', reply_markup=keyboard)


@bot.callback_query_handler(func=lambda call: call.data in ['Gamestracker.org', 'GTorrent.ru', 'Rutor.info'])
def callback_query(call):
    global tracker
    bot.delete_message(search[call.message.chat.id].chat.id, search[call.message.chat.id].message_id)
    tracker[call.message.chat.id] = call.data
    msg = bot.send_message(call.message.chat.id, '–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –∑–∞–ø—Ä–æ—Å‚úíÔ∏è')
    bot.register_next_step_handler(msg, send_urls)


def send_urls(message: Message) -> None:
    global data_torrents, torrent_msg
    if message.content_type != 'text':
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')
    else:
        search_msg[message.chat.id] = message.text
        if message.chat.id in data_torrents:
            bot.delete_message(torrent_msg[message.chat.id].chat.id, torrent_msg[message.chat.id].message_id)
        try:
            if tracker[message.chat.id] == URLS['torrent']['name']:
                data_torrents[message.chat.id] = get_torrents1(message.text)
            elif tracker[message.chat.id] == URLS['torrent2']['name']:
                data_torrents[message.chat.id] = get_torrents2(message.text)
            elif tracker[message.chat.id] == URLS['torrent3']['name']:
                data_torrents[message.chat.id] = get_torrents3(message.text)
        except requests.exceptions.ConnectionError:
            bot.send_message(message.chat.id, '–í–æ–∑–Ω–∏–∫–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞üòî')
        else:
            if data_torrents[message.chat.id]:
                create_data_torrents(message)
                torrent_msg[message.chat.id] = bot.send_message(message.chat.id, '–ó–∞–≥—Ä—É–∑–∫–∞...')
                torrent_keyboard(torrent_msg[message.chat.id], 0)
            else:
                torrent_msg[message.chat.id] = bot.send_message(message.chat.id, '–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–æ—Å—åüòî')


def create_data_torrents(message: Message) -> None:
    list_torrent, buf = [], []
    for i, en in enumerate(data_torrents[message.chat.id], 1):
        buf.append(en)
        if i % 5 == 0:
            list_torrent.append(buf.copy())
            buf.clear()
    if buf:
        list_torrent.append(buf.copy())
    data_torrents[message.chat.id] = list_torrent.copy()


def torrent_keyboard(message: Message, index: int) -> None:
    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton(text="‚¨ÖÔ∏èÔ∏è", callback_data=f"torrent_move_to {index - 1 if index > 0 else 'pass'}"),
                 InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"torrent_move_to "
                                      f"{index + 1 if index < len(data_torrents[message.chat.id]) - 1 else 'pass'}"))
    text_t = None
    if tracker[message.chat.id] == URLS['torrent']['name']:
        text_t = f'<a href="{URLS["torrent"]["main"]}">{tracker[message.chat.id]}üá∑üá∫</a>\n–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞ <b>' \
                 f'{search_msg[message.chat.id]}</b>'
    elif tracker[message.chat.id] == URLS['torrent2']['name']:
        text_t = f'<a href="{URLS["torrent2"]["main"]}">{tracker[message.chat.id]}üá∑üá∫</a>\n–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞ <b>' \
                 f'{search_msg[message.chat.id]}</b>'
    elif tracker[message.chat.id] == URLS['torrent3']['name']:
        text_t = f'<a href="{URLS["torrent3"]["main"]}">{tracker[message.chat.id]}üá∑üá∫</a>\n–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞ <b>' \
                 f'{search_msg[message.chat.id]}</b>'
    try:
        for i in data_torrents[message.chat.id][index]:
            if tracker[message.chat.id] == 'GTorrent.ru':
                text_t += f'\n\n{i["name"]} | [{i["size"]}] \n[<i>/download_{i["link_t"]}</i>] ' \
                          f'[<a href="{i["link"]}">—Ä–∞–∑–¥–∞—á–∞</a>]'
            elif tracker[message.chat.id] == 'Gamestracker.org':
                link_t = i["link_t"].split('-')
                link_t = link_t[-2] + '_' + link_t[-1]
                text_t += f'\n\n{i["name"]} | {i["size"]} \n[<i>/download_{link_t}</i>] ' \
                          f'[<a href="{i["link"]}">—Ä–∞–∑–¥–∞—á–∞</a>]'
            elif tracker[message.chat.id] == 'Rutor.info':
                text_t += f'\n\n{i["name"]} | [{i["size"]}] \n[<i>/download__{i["link_t"].split("/")[-1]}</i>] ' \
                          f'[<a href="{i["link"]}">—Ä–∞–∑–¥–∞—á–∞</a>]'
    except KeyError:
        log('Key Error in torrents', 'warning')
    else:
        bot.edit_message_text(chat_id=torrent_msg[message.chat.id].chat.id,
                                                 message_id=torrent_msg[message.chat.id].message_id,
                                                 text=text_t, reply_markup=keyboard, parse_mode='HTML',
                                                 disable_web_page_preview=True)


@bot.message_handler(func=lambda message: re.match(r'^/\w{8}_\d+_\d+$', str(message.text), flags=re.M))
def load_handler(message: Message):
    id_torrent =  message.text.split("_")[1] + '-' +  message.text.split("_")[2]
    for torrent in data_torrents[message.chat.id]:
        for item in torrent:
            if item['link_t'].endswith(id_torrent):
                with open(f'file{id_torrent}.torrent', 'wb') as f:
                    for link in requests.get(URLS['torrent3']['download'] + id_torrent, stream=True).iter_content(1024):
                        f.write(link)
                bot.send_document(message.chat.id, open(f'file{id_torrent}.torrent', 'rb'))
                try:
                    os.remove(os.path.join(os.path.abspath(os.path.dirname(__file__)), f'file{id_torrent}.torrent'))
                except (FileNotFoundError, NameError):
                    log('Error! Can\'t remove file', 'warning')


@bot.message_handler(func=lambda message: re.match(r'^/\w{8}__\d+$', str(message.text), flags=re.M))
def load_handler(message: Message):
    id_torrent = message.text.split("_")[-1]
    with open(f'file{id_torrent}.torrent', 'wb') as f:
        for torrent in requests.get(URLS['torrent3']['download'] + id_torrent, stream=True).iter_content(1024):
            f.write(torrent)
    bot.send_document(message.chat.id, open(f'file{id_torrent}.torrent', 'rb'))
    try:
        os.remove(os.path.join(os.path.abspath(os.path.dirname(__file__)), f'file{id_torrent}.torrent'))
    except (FileNotFoundError, NameError):
        log('Error! Can\'t remove file', 'warning')


@bot.message_handler(func=lambda message: re.match(r'^/\w{8}_\d+$', str(message.text), flags=re.M))
def load_handler(message: Message):
    id_torrent = message.text.split("_")[1]
    with open(f'file{id_torrent}.torrent', 'wb') as f:
        for torrent in requests.get(URLS['torrent3']['download'] + id_torrent, stream=True).iter_content(1024):
            f.write(torrent)
    bot.send_document(message.chat.id, open(f'file{id_torrent}.torrent', 'rb'))
    try:
        os.remove(os.path.join(os.path.abspath(os.path.dirname(__file__)), f'file{id_torrent}.torrent'))
    except (FileNotFoundError, NameError):
        log('Error! Can\'t remove file', 'warning')


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^torrent_move_to\s\d+$', call.data))
def callback_query(call):
    index = int(call.data.split()[1])
    if 0 <= index < len(data_torrents[call.message.chat.id]):
        bot.answer_callback_query(call.id, f'–í—ã –≤—ã–±—Ä–∞–ª–∏ —Å—Ç—Ä.{index + 1}')
        torrent_keyboard(call.message, index)
    else:
        bot.answer_callback_query(call.id, '‚õîÔ∏è')


# <<< End torrent >>>


# <<< Translate >>>
@bot.message_handler(commands=['translate'])
def translate_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /translate to translate any sentence on any leng to russian or russian sentence to english
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        bot.send_chat_action(message.chat.id, 'typing')
        msg = bot.send_message(message.chat.id, '–í–≤–µ–¥–∏—Ç–µ —Ç–æ —á—Ç–æ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–≤–µ—Å—Ç–∏üëÅ‚Äçüó®')
        bot.register_next_step_handler(msg, trans_word)


def trans_word(message: Message) -> None:  # Translate function
    bot.send_chat_action(message.chat.id, 'typing')
    bot.send_message(message.chat.id, tr_w(message.text))


# <<< End Translate >>>


# <<< Sticker GN >>>
@bot.message_handler(commands=['sticker_gn'])
def gn_sticker_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /sticker_gn to get random sticker from GN, access limited
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        if db.check(message.from_user.id, 'is_gn'):
            bot.send_sticker(message.chat.id, db.random_sticker(True))
        else:
            bot.send_message(message.chat.id, '–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤–∞–º –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞üòî')


# <<< End sticker GN >>>


# <<< Sticker >>>
@bot.message_handler(commands=['sticker'])
def sticker_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /sticker to get random sticker
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        bot.send_sticker(message.chat.id, db.random_sticker())


# <<< End sticker >>>


# <<< Add new sticker >>>
@bot.message_handler(content_types=['sticker'])
def add_sticker_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Send sticker in chat with bot to add him in our database
    """
    if message.chat.type != 'private':
        db.change_karma(message.from_user.id, '+', 1)
    db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
    db.add_sticker(message.sticker.file_id, message.sticker.emoji, message.sticker.set_name)


# <<< End add new sticker  >>>


# <<< Stat  >>>
@bot.message_handler(commands=['stat'])
def stat_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /stat to see statistic in group
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
            data = db.get_from(message.chat.id, 'Users_stat')
            if data:
                keyboard = InlineKeyboardMarkup()
                msg = bot.send_message(message.chat.id, '–ó–∞–≥—Ä—É–∑–∫–∞...')
                keyboard.add(InlineKeyboardButton('–ó–∞–∫—Ä—ã—Ç—å', callback_data=f'del {msg.message_id} {message.message_id}'))
                text = '<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n'
                for en, i in enumerate(data, 1):
                    if en == 6:
                        break
                    medal = 'ü•á' if en == 1 else 'ü•à' if en == 2 else 'ü•â' if en == 3 else None
                    text += f"<i>{en}.</i> {i['first_name']} {i['last_name'] if i['last_name'] != 'None' else ''}" \
                            f" - <b>{i['karma']}</b>/<b>{get_lvl(int(i['karma']))}</b> lvl {medal if medal is not None else ''} \n"
                text += '...\n–ù–∞–∂–º–∏—Ç–µ /me —á—Ç–æ –±—ã —É–≤–∏–¥–µ—Ç—å —Å–µ–±—è'
                bot.edit_message_text(chat_id=msg.chat.id, message_id=msg.message_id,
                                      text=text,
                                      reply_markup=keyboard, parse_mode='HTML')
        else:
            bot.send_message(message.chat.id, '–§—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç–ø—É–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Öüòî')


# <<< End Stat >>>


# <<< Me >>>
@bot.message_handler(commands=['me'])
def me_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /me to see your stat in group
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
            keyboard = InlineKeyboardMarkup()
            data_user, position = db.get_user(message.from_user.id, message.chat.id)
            msg = bot.send_message(message.chat.id, '–ó–∞–≥—Ä—É–∑–∫–∞...')
            keyboard.add(InlineKeyboardButton('–ó–∞–∫—Ä—ã—Ç—å', callback_data=f'del {msg.message_id} {message.message_id}'))
            if data_user is not False or position is not False:
                user = f"{data_user['first_name'] + ' ' + data_user['last_name']}" if data_user['last_name'] != 'None' else data_user['first_name']
                bot.edit_message_text(chat_id=message.chat.id, message_id=msg.message_id, text=f'–í–∞—à —Ä–µ–π—Ç–∏–Ω–≥:\n'
                                                            f'<i>{position}. </i>'
                                                            f'<b>{user}</b> - '
                                                            f'<b>{data_user["karma"]}</b>/<b>{get_lvl(int(data_user["karma"]))}</b> lvlüèÜ',
                                                             parse_mode='HTML', reply_markup=keyboard)
        else:
            bot.send_message(message.chat.id, '–§—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç–ø—É–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Öüòî')


# <<< End me >>>


# <<< Feedback >>>
@bot.message_handler(commands=['feedback'])
def feedback_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /feedback to sand feedback to admin
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        db.change_karma(message.from_user.id, '+', 10)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        msg = bot.send_message(message.chat.id, '<b>–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∏–∂–µ</b>üìù\n'
                                                '–í –∫—Ä–∞—Ç—á–∞–π—à–∏–µ —Å—Ä–æ–∫–∏ –æ–Ω–æ –±—É–¥–µ—Ç –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω–æ –∞–¥–º–∏–Ω–∏—Ç—Ä–∞—Ü–∏–µ–πüôÉ', parse_mode='HTML')
        bot.register_next_step_handler(msg, send_to_admin)


def send_to_admin(message: Message) -> None:
    bot.send_message(message.chat.id, '–í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æüòå')
    keyboard = InlineKeyboardMarkup()
    msg = bot.send_message(Admins[0], f'–í–∞–º –ø—Ä–∏—à–µ–ª <b>feedback</b> –æ—Ç <b>{message.from_user.first_name}</b> '
                               f'<b>{message.from_user.last_name if message.from_user.last_name is not None else ""}</b>\n'
                               f'–¢–µ–∫—Å—Ç: {message.text}')
    keyboard.add(InlineKeyboardButton('–û—Ç–≤–µ—Ç–∏—Ç—å', callback_data=f'answer_feedback {message.chat.id}'))
    bot.edit_message_text(msg.text, msg.chat.id, msg.message_id, reply_markup=keyboard, parse_mode='HTML')


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^answer_feedback\s.+', call.data))
def answer_feedback_query(call):
    msg = bot.send_message(call.message.chat.id, '<b>–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∏–∂–µ</b>üìù', parse_mode='HTML')
    bot.register_next_step_handler(msg, answer_feedback, call.data.split()[1])

def answer_feedback(message: Message, chat_id: str) -> None:
    bot.send_message(message.chat.id, '–í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æüòå')
    bot.send_message(chat_id, f"<b>–ù–∞ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∏–ª–∏</b> \n–û—Ç–≤–µ—Ç: {message.text}\n\n<b>–°–ø–∞—Å–∏–±–æ –∑–∞ –æ–±—Ä–∞—â–µ–Ω–∏–µ</b>üòè",
                     parse_mode='HTML')
# <<< End feedback >>>


# <<< Project Euler >>>
data_euler = defaultdict(list)


@bot.message_handler(commands=['euler'])
def euler_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /euler to get random task from Project Euler
    """
    global data_euler
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        keyboard = InlineKeyboardMarkup()
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        if message.chat.id not in data_euler or len(data_euler[message.chat.id]) == 1:
            data_euler[message.chat.id] = db.get_all('Project_Euler')
        task = data_euler[message.chat.id].pop(random.randint(1, len(data_euler[message.chat.id]) - 1))
        data_msg = [bot.send_photo(message.chat.id, image) for image in  task['image_url'].split(',')]
        id_s = str(message.message_id)
        for i in data_msg:
            id_s += str(i.message_id) + ' '
        keyboard.add(InlineKeyboardButton('–°—Å—ã–ª–∫–∞', url=task['url']),
                     InlineKeyboardButton('–£–¥–∞–ª–∏—Ç—å', callback_data=f'del {id_s}'))
        if task['other'] != 'False':
            keyboard.add(InlineKeyboardButton(task['other'].split('/')[-1] if len(task['other'].split(',')) == 1 else '–î–æ–∫—É–º–µ–Ω—Ç—ã',
                                              callback_data=f'load doc {task["id"]}'))
        bot.edit_message_media(chat_id=data_msg[-1].chat.id, message_id=data_msg[-1].message_id,
                               media=InputMediaPhoto(data_msg[-1].photo[-1].file_id,
                               caption=f'<b>–ó–∞–¥–∞—á–∞</b> <i>‚Ññ{task["id"]}</i>\n<b><i>{task["name"]}</i></b>'
                                       f'\n\n–ü–æ–¥–µ–ª–∏—Ç—å—Å—è —Ä–µ—à–µ–Ω–∏–µ–º <i>/code</i>', parse_mode='HTML'),
                               reply_markup=keyboard)


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^load\s\w+\s\d+$', call.data))
def answer_query(call):
    urls = db.get_doc(call.data.split()[2]).split(',')
    for url in urls:
        name = url.split('/')[-1]
        bot.answer_callback_query(call.id, name)
        with open(name, 'wb') as f:
            req = requests.get(url, stream=True)
            for i in req.iter_content(1024):
                f.write(i)
        try:
            bot.send_document(call.message.chat.id, data=open(name, 'rb'))
            os.remove(os.path.join(os.path.abspath(os.path.dirname(__file__)), name))
        except (FileNotFoundError, NameError):
            log('Error! Can\'t remove file', 'warning')
        except (FileNotFoundError, FileExistsError):
            log('Error! Can\'t find file', 'warning')
# <<< End project Euler >>>


# <<< Logic tasks >>>
data_logic_tasks = defaultdict(dict)
logic_msg = defaultdict(Message)

@bot.message_handler(commands=['logic'])
def logic_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /logic to get random logic task
    """
    global data_logic_tasks, logic_msg
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        keyboard = InlineKeyboardMarkup()
        if message.chat.id not in data_logic_tasks or len(data_logic_tasks[message.chat.id]) == 1:
            data_logic_tasks[message.chat.id] = db.get_all('Logic_Tasks')
        task = data_logic_tasks[message.chat.id].pop(random.randint(0, len(data_logic_tasks[message.chat.id]) - 1))
        keyboard.add(InlineKeyboardButton('–û—Ç–≤–µ—Ç', callback_data=f'Answer {task["id"]} {message.message_id}'))
        logic_msg[message.chat.id] = bot.send_message(message.chat.id, f'<b>–ó–∞–¥–∞—á–∞ ‚Ññ</b><i>{task["id"]}</i>\n'
                                                                       f'{task["question"]}',
                                                      reply_markup=keyboard, parse_mode='HTML')


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^Answer\s.+\s.+$', call.data))
def answer_query(call):
    bot.answer_callback_query(call.id, '–û—Ç–≤–µ—Ç')
    id_answer, id_command = call.data.split()[1:]
    keyboard = InlineKeyboardMarkup()
    keyboard.add(InlineKeyboardButton('–£–¥–∞–ª–∏—Ç—å', callback_data=f'del {id_command} {logic_msg[call.message.chat.id].message_id}'))
    question = logic_msg[call.message.chat.id].text.split('\n')[1:]
    bot.edit_message_text(f'<b>–ó–∞–¥–∞—á–∞ ‚Ññ</b><i>{id_answer}</i>\n{question[0]}\n\n<b>–û—Ç–≤–µ—Ç:</b> {db.get_task_answer(id_answer)}',
                          call.message.chat.id, logic_msg[call.message.chat.id].message_id,
                          reply_markup=keyboard, parse_mode='HTML')

# <<< End logic task >>>


# <<< Wiki >>>
data_wiki = defaultdict(list)
wiki_msg = defaultdict(Message)
page_msg = defaultdict(Message)
wiki_enter_msg = defaultdict(Message)


@bot.message_handler(commands=['wiki'])
def wiki_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /wiki to get result from Wikipedia and choose page what you need to read it
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        wiki_enter_msg[message.chat.id] = bot.send_message(message.chat.id, '–í–≤–µ–¥–∏—Ç–µ –∑–∞–ø—Ä–æ—Å‚úíÔ∏è')
        bot.register_next_step_handler(wiki_enter_msg[message.chat.id], get_titles)


def get_titles(message: Message) -> None:
    global data_wiki, wiki_msg
    bot.delete_message(wiki_enter_msg[message.chat.id].chat.id, wiki_enter_msg[message.chat.id].message_id)
    bot.delete_message(message.chat.id, message.message_id)
    wikipedia.set_lang("ru")
    try:
        data_wiki[message.chat.id] = wikipedia.search(message.text, results=100, suggestion=True)
    except requests.ConnectionError:
        bot.send_message(message.chat.id, '–í–æ–∑–Ω–∏–∫–ª–∞ –Ω–µ –ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞üòî')
        log('Connection error in  wiki', 'error')
    else:
        if data_wiki[message.chat.id][0]:
            list_wiki, buf = [], []
            for i, en in enumerate(data_wiki[message.chat.id][0], 1):
                buf.append(en)
                if i % 5 == 0:
                    list_wiki.append(buf.copy())
                    buf.clear()
            if buf:
                list_wiki.append(buf.copy())
            data_wiki[message.chat.id] = list_wiki.copy()
            if message.chat.id in wiki_msg:
                bot.delete_message(wiki_msg[message.chat.id].chat.id, wiki_msg[message.chat.id].message_id)
            wiki_msg[message.chat.id] = bot.send_message(message.chat.id, '–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞:',
                             reply_markup=send_wiki(message, 0))
        else:
            bot.send_message(message.chat.id, '–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–æ—Å—åüòî')


def send_wiki(message: Message, index: int) -> None:
    keyboard = InlineKeyboardMarkup()
    try:
        for en, wiki in enumerate(data_wiki[message.chat.id][index]):
            keyboard.add(InlineKeyboardButton(f"{wiki}", callback_data=f"Wiki: {index} {en}"))
        keyboard.add(InlineKeyboardButton(text="‚¨ÖÔ∏èÔ∏è", callback_data=f"wiki_move_to {index - 1 if index > 0 else 'pass'}"),
                     InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"wiki_move_to "
                                            f"{index + 1 if index < len(data_wiki[message.chat.id]) - 1 else 'pass'}"))
        return keyboard
    except KeyError:
        log('Key Error in wiki', 'warning')


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^Wiki:\s\d+\s\d+$', call.data))
def wiki_query(call):
    global page_msg
    wiki = wikipediaapi.Wikipedia('ru')
    index1, index2 = call.data.split()[1:]
    try:
        page = wiki.page(data_wiki[call.message.chat.id][int(index1)][int(index2)].replace(' ', '_'),)
    except requests.exceptions.ConnectionError:
        bot.answer_callback_query(call.id, '‚õîÔ∏è')
        log('Connection error in  wiki', 'warning')
    except IndexError:
        bot.answer_callback_query(call.id, '‚õîÔ∏è')
        log('Key Error in wiki', 'warning')
    else:
        if page.exists():
            if call.message.chat.id in page_msg:
                bot.delete_message(page_msg[call.message.chat.id].chat.id, page_msg[call.message.chat.id].message_id)
            bot.answer_callback_query(call.id, page.title.replace('_', ' '))
            page_msg[call.message.chat.id] = bot.send_message(call.message.chat.id,
                    f'{page.summary[0:600]}...\n\n<a href="{page.fullurl}">–°—Ç–∞—Ç—å—è –Ω–∞ Wikipedia</a>', parse_mode='HTML')
        else:
            bot.send_message(call.message.chat.id, '–°—Ç–∞—Ç—å—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞üòî')



@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^wiki_move_to\s\d+$', call.data))
def wiki_move_query(call):
    index = int(call.data.split()[1])
    if 0 <= index < len(data_wiki[call.message.chat.id]):
        bot.answer_callback_query(call.id, f'–í—ã –≤—ã–±—Ä–∞–ª–∏ —Å—Ç—Ä.{index + 1}')
        bot.edit_message_text(chat_id=wiki_msg[call.message.chat.id].chat.id,
                              message_id=wiki_msg[call.message.chat.id].message_id,
                              text=wiki_msg[call.message.chat.id].text,
                              reply_markup=send_wiki(call.message, index))
    else:
        bot.answer_callback_query(call.id, '‚õîÔ∏è')

    
# <<< End Wiki >>>


# <<< Change karma >>>
time_to_change = defaultdict(dict)


@bot.message_handler(content_types=['text'], regexp=r'^\+{1,5}$')  # Change karma
@bot.message_handler(content_types=['text'], regexp=r'^\-{1,5}$')
def text_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Func to up or down karma user in group
    """
    def set_true(user_id: int) -> None:
        time_to_change[user_id] = True

    global time_to_change
    db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
    if message.from_user.id not in time_to_change:
        time_to_change[message.from_user.id] = True
    if message.chat.type != 'private' and message.reply_to_message:
        log(message, 'info')
        if message.from_user.id != message.reply_to_message.from_user.id:
            if time_to_change[message.from_user.id] is True:
                time_to_change[message.from_user.id] = False
                msg = list(message.text)
                if message.reply_to_message.from_user.first_name is not None:
                    reply_user = message.reply_to_message.from_user.first_name
                    if message.reply_to_message.from_user.last_name is not None:
                        reply_user += ' ' + message.reply_to_message.from_user.last_name
                else:
                    reply_user = message.reply_to_message.from_user.username
                if message.from_user.first_name is not None:
                    from_user = message.from_user.first_name
                    if message.from_user.last_name is not None:
                        from_user += ' ' + message.from_user.last_name
                else:
                    from_user = message.reply_to_message.from_user.username
                if msg[0] == '+':
                    bot.send_message(message.chat.id, f'<b>{from_user}</b> –ø–æ–¥–∫–∏–Ω—É–ª <i>{len(msg) * 10}</i> –∫ –∫–∞—Ä–º–µüòà '
                                                      f'<b>{reply_user}</b>\n–ò—Ç–æ–≥–æ –∫–∞—Ä–º–∞: '
                                f'<i>{db.change_karma(message.reply_to_message.from_user.id, msg[0], len(msg) * 10)}</i>',
                                     parse_mode='HTML')
                else:
                    bot.send_message(message.chat.id, f'<b>{from_user}</b> –æ—Ç–Ω—è–ª –æ—Ç –∫–∞—Ä–º—ã <i>-{len(msg) * 10}</i>üëø '
                                                      f'<b>{reply_user}</b>\n–ò—Ç–æ–≥–æ –∫–∞—Ä–º–∞: '
                                f'<i>{db.change_karma(message.reply_to_message.from_user.id, msg[0], len(msg) * 10)}</i>',
                                     parse_mode='HTML')
                Timer(60.0, set_true, [message.from_user.id]).start()
            else:
                bot.send_message(message.chat.id, '–û–ø–µ—Ä–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ –æ–¥–∏–Ω —Ä–∞–∑ –≤ 60 —Å–µ–∫—É–Ω–¥üòî\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞ –æ–∂–∏–¥–∞–π—Ç–µ')
        else:
            bot.send_message(message.chat.id, '–ù–µ–ª—å–∑—è –º–µ–Ω—è—Ç—å –∫–∞—Ä–º—É —Å–∞–º–æ–º—É —Å–µ–±–µüòî')


# <<< End change karma >>>


# <<< Settings >>>
settings_msg = defaultdict(Message)
msg_settings = defaultdict(Message)


@bot.message_handler(commands=['settings'])
def settings_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso::  Enter /settings to open setting menu
    """
    global settings_msg, msg_settings
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        msg_settings[message.chat.id] = message
        settings_msg[message.chat.id] = bot.send_message(message.chat.id, '–ó–∞–≥—Ä—É–∑–∫–∞...')
        set_settings(message.chat.id)


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^Settings\s.+\s\w+\s\w+$', call.data))
def callback_query(call):
    chat_id = int(call.data.split()[1])
    if chat_id in settings_msg:
        bot.answer_callback_query(call.id, f'{call.data.split()[3].title()}')
        db.change_setting(*call.data.split()[1:])
        set_settings(chat_id)
    else:
        bot.answer_callback_query(call.id, '‚õîÔ∏è')


def set_settings(chat_id) -> InlineKeyboardMarkup:
    keyboard = InlineKeyboardMarkup()
    data = db.get_from(chat_id, 'Setting')
    if settings_msg[chat_id].chat.type != 'private':
        keyboard.add(InlineKeyboardButton(f'–ë–æ—Ç –æ—Ç–≤–µ—á–∞–µ—Ç: {"Onüü¢" if data["speak"] == "On" else "Offüî¥"}',
                                          callback_data=f"Settings {chat_id} speak "
                                                        f"{'off' if data['speak'] == 'On' else 'on'}"))
    if data['speak'] == 'On' and settings_msg[chat_id].chat.type != 'private':
        keyboard.add(InlineKeyboardButton(f'–ü–µ—Ä–µ–æ–¥–∏—á–Ω–æ—Å—Ç—å: {"–†–µ–¥–∫–æüîª" if data["periodicity"] == "Rarely" else "–ß–∞—Å—Ç–æüî∫" if data["periodicity"] == "Often" else "–ù–æ—Ä–º–∞–ª—å–Ω–æ" + "‚ô¶Ô∏è"}',
                                 callback_data=f"Settings {chat_id} periodicity "
                                               f"{'rarely' if data['periodicity'] == 'Often' else 'often' if data['periodicity'] == 'Normal' else 'normal'}"))
    keyboard.add(InlineKeyboardButton(f'–¶–µ–Ω–∑—É—Ä–∞: {"Onüü¢" if data["censure"] == "On" else "Offüî¥"}',
                                      callback_data=f"Settings {chat_id} censure "
                                                    f"{'off' if data['censure'] == 'On' else 'on'}"))
    if settings_msg[chat_id].chat.type != 'private':
        keyboard.add(InlineKeyboardButton(f'–ü–∏–¥–æ—Ä –¥–Ω—è: {"Onüü¢" if data["bad_guy"] == "On" else "Offüî¥"}',
                                          callback_data=f"Settings {chat_id} bad_guy "
                                                        f"{'off' if data['bad_guy'] == 'On' else 'on'}"))
        keyboard.add(InlineKeyboardButton(f'–ö–∞–∑–∏–Ω–æ: {"Onüü¢" if data["roulette"] == "On" else "Offüî¥"}',
                                          callback_data=f"Settings {chat_id} roulette "
                                                        f"{'off' if data['roulette'] == 'On' else 'on'}"))
        if data['roulette'] == 'On':
            keyboard.add(InlineKeyboardButton(f'–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ: {"Onüü¢" if data["alert"] == "On" else "Offüî¥"}',
                                              callback_data=f"Settings {chat_id} alert "
                                                            f"{'off' if data['alert'] == 'On' else 'on'}"))
    keyboard.add(InlineKeyboardButton(f'–ù–æ–≤–æ—Å—Ç–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: {"Onüü¢" if data["path_news"] == "On" else "Offüî¥"}',
                                      callback_data=f"Settings {chat_id} path_news "
                                                    f"{'off' if data['path_news'] == 'On' else 'on'}"))
    keyboard.add(InlineKeyboardButton(f'–ù–æ–≤–æ—Å—Ç–∏: {"UAüá∫üá¶" if data["news"] == "Ua" else "RUüá∑üá∫" if data["news"] == "Ru" else "USüá∫üá∏"}',
                                      callback_data=f"Settings {chat_id} news "
                                                    f"{'ru' if data['news'] == 'Ua' else 'ua' if data['news'] == 'Us' else 'us'}"))
    keyboard.add(InlineKeyboardButton(f'–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ –Ω–æ–≤–æ—Å—Ç–∏: {"Onüü¢" if data["news_mailing"] == "On" else "Offüî¥"}',
                                      callback_data=f"Settings {chat_id} news_mailing "
                                                    f"{'off' if data['news_mailing'] == 'On' else 'on'}"))
    keyboard.add(InlineKeyboardButton(f'–ú–µ–º—ã: {"RUüá∑üá∫" if data["meme"] == "Ru" else "USüá∫üá∏"}',
                                      callback_data=f"Settings {chat_id} meme "
                                                    f"{'ru' if data['meme'] == 'En' else 'en'}"))
    keyboard.add(InlineKeyboardButton(f'–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏: '
                f'{"Wixüé§" if data["recognize"] == "Wix" else "Googleüéô" if data["recognize"] == "Google" else "Offüî¥"}',
                                      callback_data=f"Settings {chat_id} recognize "
                    f"{'off' if data['recognize'] == 'Google' else 'wix' if data['recognize'] == 'Off' else 'google'}"))
    if data['recognize'] == 'Google':
        keyboard.add(
            InlineKeyboardButton(f'–Ø–∑—ã–∫: {"RUüá∑üá∫" if data["leng_speak"] == "Ru" else "UAüá∫üá¶" if data["leng_speak"] == "Ua" else "USüá∫üá∏"}',
                                 callback_data=f"Settings {chat_id} leng_speak "
                                               f"{'ru' if data['leng_speak'] == 'Ua' else 'ua' if data['leng_speak'] == 'Us' else 'us'}"))
    keyboard.add(InlineKeyboardButton(f'–•—Ä–∞–Ω–µ–Ω–∏–µ PasteBin: {"1 –ß–∞—Åüï∞" if data["pastebin"] == "1H" else "1 –ù–µ–¥–µ–ª—èüï∞" if data["pastebin"] == "1W" else "1 –ú–µ—Å—è—Üüï∞"}',
        callback_data=f"Settings {chat_id} pastebin "
                      f"{'1W' if data['pastebin'] == '1H' else '1M' if data['pastebin'] == '1W' else '1H'}"))
    keyboard.add(InlineKeyboardButton('–ó–∞–∫—Ä—ã—Ç—å', callback_data=f'del {settings_msg[chat_id].message_id} '
                                                               f'{msg_settings[chat_id].message_id}'))
    bot.edit_message_text(chat_id=chat_id, message_id=settings_msg[chat_id].message_id,
                          text='–ù–∞—Å—Ç—Ä–æ–π–∫–∏:', reply_markup=keyboard)
# <<< End settings >>>


# <<< Code PasteBin >>>
lang_msg = defaultdict(Message)


@bot.message_handler(commands=['code'])
def code_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /code to get link on you program code on PasteBin
    """
    global lang_msg
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        if message.chat.type != 'private':
            db.change_karma(message.from_user.id, '+', 1)
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        keyboard = InlineKeyboardMarkup(row_width=3)
        lang_msg[message.chat.id] = bot.send_message(message.chat.id, '–ó–∞–≥—Ä—É–∑–∫–∞...')
        keyboard.add(InlineKeyboardButton('Bash', callback_data=f'Code bash {message.message_id}'),
                     InlineKeyboardButton('HTML 5', callback_data=f'Code html5 {message.message_id}'),
                     InlineKeyboardButton('CSS', callback_data=f'Code css {message.message_id}'))
        keyboard.add(InlineKeyboardButton('JavaScript', callback_data=f'Code javascript {message.message_id}'),
                     InlineKeyboardButton('Pascal', callback_data=f'Code pascal {message.message_id}'),
                     InlineKeyboardButton('JSON', callback_data=f'Code json {message.message_id}'))
        keyboard.add(InlineKeyboardButton('Perl', callback_data=f'Code perl {message.message_id}'),
                     InlineKeyboardButton('C#', callback_data=f'Code csharp {message.message_id}'),
                     InlineKeyboardButton('Objective C', callback_data=f'Code objc {message.message_id}'))
        keyboard.add(InlineKeyboardButton('C', callback_data=f'Code c {message.message_id}'),
                     InlineKeyboardButton('C++', callback_data=f'Code cpp {message.message_id}'),
                     InlineKeyboardButton('Ruby', callback_data=f'Code ruby {message.message_id}'))
        keyboard.add(InlineKeyboardButton('Delphi', callback_data=f'Code delphi {message.message_id}'),
                     InlineKeyboardButton('Java', callback_data=f'Code java {message.message_id}'),
                     InlineKeyboardButton('CoffeeScript', callback_data=f'Code coffeescript {message.message_id}'))
        keyboard.add(InlineKeyboardButton('PHP', callback_data=f'Code php {message.message_id}'),
                     InlineKeyboardButton('Python', callback_data=f'Code python {message.message_id}'),
                     InlineKeyboardButton('PostgreSQL', callback_data=f'Code postgresql {message.message_id}'))
        keyboard.add(InlineKeyboardButton('SQL', callback_data=f'Code sql {message.message_id}'),
                     InlineKeyboardButton('Swift', callback_data=f'Code swift {message.message_id}'),
                     InlineKeyboardButton('Rust', callback_data=f'Code rust {message.message_id}'))
        keyboard.add(InlineKeyboardButton('–í—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —è–∑—ã–∫–∏', url='https://' + 'pastebin.com/languages'))
        keyboard.add(InlineKeyboardButton('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω—É–∂–Ω–æ–≥–æ —è–∑—ã–∫–∞ –Ω–∏–∂–µ', callback_data='Enter lang'))
        bot.edit_message_text('–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—ã–π –≤–∞–º —è–∑—ã–∫üòà',
                                                          lang_msg[message.chat.id].chat.id,
                                                          lang_msg[message.chat.id].message_id, reply_markup=keyboard)
        bot.register_next_step_handler(lang_msg[message.chat.id], callback_to_code, message.message_id)


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^Enter lang$', call.data))
def callback_query(call):
    bot.answer_callback_query(call.id, '–í–≤–µ–¥–∏—Ç–µ –Ω—É–∂–Ω—ã–π —è–∑—ã–∫ –Ω–∏–∂–µ')


def callback_to_code(message: Message, message_id: int) -> None:
    if type(lang_msg[message.chat.id]) == Message:
        if message.content_type != 'text':
            bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')
        else:
            bot.delete_message(message.chat.id, message_id)
            bot.delete_message(message.chat.id, message.message_id)
            bot.delete_message(message.chat.id, lang_msg[message.chat.id].message_id)
            lang = db.get_code(message.text)
            if lang is not None:
                code = bot.send_message(message.chat.id, '–û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ –≤–∞—à –∫–æ–¥üëæ')
                bot.register_next_step_handler(code, set_name, lang['code'], code.message_id)
            else:
                bot.send_message(message.chat.id, '–≠—Ç–æ—Ç —è–∑—ã–∫ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Öüòî')


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^Code\s\w+\s\d+$', call.data))
def code_callback_query(call):
    global lang_msg
    lang, message_id = call.data.split()[1:]
    bot.delete_message(call.message.chat.id, message_id)
    bot.delete_message(call.message.chat.id, lang_msg[call.message.chat.id].message_id)
    lang_msg[call.message.chat.id] = lang
    bot.answer_callback_query(call.id, '–í—ã –≤—ã–±—Ä–∞–ª–∏ ' + lang)
    msg = bot.send_message(call.message.chat.id, '–û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ –≤–∞—à –∫–æ–¥üëæ')
    bot.register_next_step_handler(msg, set_name, lang, msg.message_id)


def set_name(message: Message, leng: str, message_id: int) -> None:
    if message.content_type != 'text':
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')
    else:
        bot.delete_message(message.chat.id, message_id)
        bot.delete_message(message.chat.id, message.message_id)
        name = bot.send_message(message.chat.id, '–£–∫–∞–∂–∏—Ç–µ –∏–º—è –ø—Ä–æ–µ–∫—Ç–∞üí°')
        bot.register_next_step_handler(name, get_url, message.text, leng, name.message_id)


def get_url(message: Message, code: str, leng: str, message_id: int) -> None:
    if message.content_type != 'text':
        bot.send_message(message.chat.id, '–ù–µ –≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Öüòî')
    else:
        bot.delete_message(message.chat.id, message_id)
        bot.delete_message(message.chat.id, message.message_id)
        settings = db.get_from(message.chat.id, 'Setting')
        values = {'api_option': 'paste', 'api_dev_key': f"{API['PasteBin']['DevApi']}",
                  'api_paste_code': f'{code}', 'api_paste_private': '0',
                  'api_paste_name': f'{message.text}', 'api_paste_expire_date': f'{"1H" if settings["pastebin"] == "1H" else "1W" if  settings["pastebin"] == "1W" else "1M"}',
                  'api_paste_format': f'{leng}', 'api_user_key': f"{API['PasteBin']['UserApi']}"}
        data = parse.urlencode(values).encode('utf-8')
        req = request.Request(API['PasteBin']['URL'], data)
        with request.urlopen(req) as response:
            url_bin = str(response.read()).replace('b\'', '').replace('\'', '')
        bot.send_chat_action(message.chat.id, 'typing')
        time.sleep(1)
        bot.send_message(message.chat.id, url_bin)


# <<< End code PasteBin >>>


# <<< Dice game >>>
first_dice: dict = {'user': None, 'dice': 0}
second_dice: dict = {'user': None, 'dice': 0}


@bot.message_handler(commands=['dice'])
@bot.message_handler(content_types=['dice'])
def dice_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Enter /dice or send emodji :dice: to play a dice with any member
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        if message.content_type != 'dice':
            res = bot.send_dice(message.chat.id)
        else:
            res = message
        t = Timer(60.0, reset_users)
        if first_dice['user'] is None:
            first_dice['user'], first_dice['dice'] = message.from_user, res.dice.value
            t.start()
        elif second_dice['user'] is None:
            second_dice['user'], second_dice['dice'] = message.from_user, res.dice.value
            if first_dice['user'].id != second_dice['user'].id:
                t.cancel()
                bot.send_chat_action(message.chat.id, 'typing')
                time.sleep(4.5)
                if first_dice['dice'] > second_dice['dice']:
                    bot.send_message(message.chat.id,
                                     f"{first_dice['user'].first_name} {first_dice['user'].last_name if first_dice['user'].last_name is not None else ''}ü•á –ø–æ–±–µ–¥–∏–ª "
                                     f"{second_dice['user'].first_name} {second_dice['user'].last_name if second_dice['user'].last_name is not None else ''}ü•à")
                elif first_dice['dice'] < second_dice['dice']:
                    bot.send_message(message.chat.id,
                                     f"{second_dice['user'].first_name} {second_dice['user'].last_name if second_dice['user'].last_name is not None else ''}ü•á –ø–æ–±–µ–¥–∏–ª "
                                     f"{first_dice['user'].first_name} {first_dice['user'].last_name if first_dice['user'].last_name is not None else ''}ü•à")
                else:
                    bot.send_message(message.chat.id, '–ü–æ–±–µ–¥–∏–ª–∞ –¥—Ä—É–∂–±–∞ü§ù')
                reset_users()
            else:
                first_dice['user'], first_dice['dice'] = message.from_user, res.dice.value
                t.cancel()
                t.start()


def reset_users() -> None:  # Reset users for Dice game
    first_dice['user'] = None
    first_dice['dice'] = 0
    second_dice['user'] = None
    second_dice['dice'] = 0


# <<< End dice game >>>


# <<< Admin menu >>>
@bot.message_handler(content_types=['text'], regexp=r'^!ban$')
def text_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: !ban func for admins
    """
    log(message, 'info')
    if message.chat.type != 'private':
        ban(message)
    else:
        bot.send_message(message.chat.id, '–§—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Öüòî')


def ban(message: Message, chat=None, user=None):
    if user is None and chat is None:
        user = message.reply_to_message.from_user.id
        chat = message.chat.id
    if str(user) == str(message.from_user.id):
        bot.send_message(message.chat.id, '–ù–µ–ª—å–∑—è –∑–∞–±–∞–Ω–∏—Ç—å —Å–∞–º–æ–≥–æ —Å–µ–±—èüòî')
        return
    else:
        for i in bot.get_chat_administrators(message.chat.id):
            if str(i.user.id) == str(user):
                bot.send_message(message.chat.id, '–ù–µ–ª—å–∑—è –∑–∞–±–∞–Ω–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞üòî')
                return
        else:
            for i in bot.get_chat_administrators(message.chat.id):
                if i.user.id == message.from_user.id:
                    db.ban_user(user)
                    bot.send_message(message.chat.id, f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–∞–Ω–µ–Ω –Ω–∞–≤—Å–µ–≥–¥–∞üòà')
                    bot.kick_chat_member(chat, user)
                    return
            else:
                bot.send_message(message.chat.id, '–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æüòî')


@bot.message_handler(content_types=['text'], regexp=r'^!mute\s\d+$')
def text_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: !mute {some_time} func for admin
    """
    log(message, 'info')
    if message.chat.type != 'private':
        mute(message, message.text.split()[1])
    else:
        bot.send_message(message.chat.id, '–§—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Öüòî')


def mute(message: Message, time_mute=30, chat=None, user=None):
    if user is None and chat is None:
        user = message.reply_to_message.from_user.id
        chat = message.chat.id
    if str(user) == str(message.from_user.id):
        bot.send_message(message.chat.id, '–ù–µ–ª—å–∑—è –∑–∞–º—É—Ç–∏—Ç—å —Å–∞–º–æ–≥–æ —Å–µ–±—èüòî')
        return
    else:
        for i in bot.get_chat_administrators(message.chat.id):
            if str(i.user.id) == str(user):
                bot.send_message(message.chat.id, '–ù–µ–ª—å–∑—è –∑–∞–º—É—Ç–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞üòî')
                return
        else:
            for i in bot.get_chat_administrators(message.chat.id):
                if i.user.id == message.from_user.id:
                    bot.restrict_chat_member(chat, user,  until_date=time.time() + int(time_mute) * 60,
                                             can_send_messages=False,
                                             can_send_other_messages=False, can_send_media_messages=False)
                    bot.send_message(message.chat.id, f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–º—É—á–µ–Ω –Ω–∞ {time_mute} –º–∏–Ωü§ê')
                    return
            else:
                bot.send_message(message.chat.id, '–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æüòî')


@bot.message_handler(content_types=['text'], regexp=r'^!kick$')
def text_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: !kick func for admin
    """
    log(message, 'info')
    if message.chat.type != 'private':
        kick(message)
    else:
        bot.send_message(message.chat.id, '–§—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Öüòî')


def kick(message: Message, chat=None, user=None):
    if user is None and chat is None:
        user = message.reply_to_message.from_user.id
        chat = message.chat.id
    if str(user) == str(message.from_user.id):
        bot.send_message(message.chat.id, '–ù–µ–ª—å–∑—è –∫–∏–∫–Ω—É—Ç—å —Å–∞–º–æ–≥–æ —Å–µ–±—èüòî')
    else:
        for i in bot.get_chat_administrators(message.chat.id):
            if str(i.user.id) == str(user):
                bot.send_message(message.chat.id, '–ù–µ–ª—å–∑—è –∫–∏–∫–Ω—É—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞üòî')
                return
        else:
            for i in bot.get_chat_administrators(message.chat.id):
                if i.user.id == message.from_user.id:
                    bot.kick_chat_member(chat, user)
                    bot.send_message(message.chat.id, '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∫–∏–∫–Ω—É—Çüòà')
                    return
            else:
                bot.send_message(message.chat.id, '–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æüòî')


# <<< End admin menu >>>


# <<< All message >>>
@bot.message_handler(content_types=['text'])
@bot.edited_message_handler(content_types=['text'])
def text_handler(message: Message) -> None:
    """
    :param message
    :type message: telebot.types.Message
    :return: None
    .. seealso:: Check all messages by command or answer on random message
    """
    if str(dt.fromtimestamp(message.date).strftime('%Y-%m-%d %H:%M')) == str(dt.now().strftime('%Y-%m-%d %H:%M')):
        log(message, 'info')
        db.add_user(message.from_user) if message.chat.type == 'private' else db.add_user(message.from_user, message.chat)
        if str(message.from_user.id) in Admins and message.forward_from_chat is not None:
            if str(message.forward_from_chat.id) == '-1001304250568':
                db.add_joke(message.text.split('\n')[0], message.text.split('\n')[2])
        text = message.text.lower()
        if text in ['—Å—Ç–∏–∫–µ—Ä', '—Å—Ç–∏–∫–µ—Ä–æ—á–µ–∫', 'sticker']:
            gn_sticker_handler(message)
        elif text in ['–≥–∏—Ñ–∫–∞', '–≥–∏—Ñ', '–≥–∏—Ñ–æ–Ω', 'gif']:
            gif_handler(message)
        elif text in ['–º–µ–º', '–º–µ–º–∞—Å', '–º–µ–º—á–∏–∫', 'meme']:
            meme_handler(message)
        elif text in ['—à—É—Ç–∫–∞', '—à—É—Ç–∫—É', 'joke', 'joke']:
            joke_handler(message)
        elif text in ['–∫—É–±–∏–∫', '–∑–∞—Ä–∏–∫', '–∫–æ—Å—Ç—å', 'dice']:
            dice_handler(message)
        elif text in ['—Ö–µ–Ω—Ç–∞–π', 'hentai', '–ª–æ–ª–∏', 'loli', '–¥–µ–≤—É—à–∫–∞', 'girl', '–±–∞–±–∞', '–ø–∏–∑–¥–∞']:
            forbidden_handler(message)
        settings = db.get_from(message.chat.id, 'Setting')
        if message.chat.type != 'private' and not message.edit_date:
            count_symbols = len(message.text)
            if count_symbols > 75:
                db.change_karma(message.from_user.id, '+', 7)
            elif count_symbols > 50:
                db.change_karma(message.from_user.id, '+', 5)
            elif count_symbols > 30:
                db.change_karma(message.from_user.id, '+', 3)
            elif count_symbols > 10:
                db.change_karma(message.from_user.id, '+', 1)
            if str(message.from_user.id) != GNBot_ID and settings['speak'] == 'On':
                if settings['periodicity'] == 'Rarely':
                    percent = [4, 1, 30]
                elif settings['periodicity'] == 'Normal':
                    percent = [7, 3, 45]
                else:
                    percent = [15, 5, 60]
                if message.reply_to_message is not None:
                    if message.reply_to_message.from_user.id == int(GNBot_ID) and rend_d(percent[2]):
                        answer = db.get_answer()
                        bot.reply_to(message, answer[0].upper() + answer[1:].lower())
                elif rend_d(percent[0]):
                    answer = db.get_answer()
                    bot.reply_to(message, answer[0].upper() + answer[1:].lower())
                elif rend_d(percent[1]):
                        bot.send_sticker(message.chat.id, db.random_sticker(), message.message_id)


# <<< End all message >>>


# <<< Answer's  >>>
@bot.message_handler(content_types=['new_chat_members'])  # Answer on new member
def new_member_handler(message: Message) -> None:
    for user in message.new_chat_members:
        if db.check_ban_user(user.id) and user.id != int(GNBot_ID):
            keyboard = InlineKeyboardMarkup()
            keyboard.add(InlineKeyboardButton('–ö–∏–∫–Ω—É—Ç—åü•ä', callback_data=f'Kick '
                                                                       f'{message.chat.id} {user.id}'),
                         InlineKeyboardButton('–ó–∞–±–∞–Ω–∏—Ç—åüö´', callback_data=f'Ban '
                                                                        f'{message.chat.id} {user.id}'),
                         InlineKeyboardButton('–ó–∞–º—É—Ç–∏—Ç—å‚ùå', callback_data=f'Mute '
                                                                          f'{message.chat.id} {user.id}')
                         )
            msg = bot.send_message(message.chat.id, random.choice(['–û–ø–∞ —á–∏—Ä–∏–∫! –í–µ—á–µ—Ä –≤ —Ö–∞—Ç—É', '–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é —Ç–µ–±—è',
                                                              '–ê–ª–æ—Ö–∞ –¥—Ä—É–≥ –º–æ–π!', '–ù—É –ø—Ä–∏–≤–µ—Ç)', '–•–µ–ª–æ –º–∞–π —Ñ—Ä–µ–Ω–¥',
                                                              '–†–∞–¥—ã –≤–∞—Å –≤–∏–¥–µ—Ç—å –≥–æ—Å–ø–æ–¥–∏–Ω', '–í –Ω–∞—à–∏—Ö —Ä—è–¥–∞—Ö –ø–æ–ø–ª–Ω–µ–Ω–∏–µ',
                                                              '–ù–æ–≤–æ–±—Ä–∞–Ω–µ—Ü!', '–†—è–¥–æ–≤–æ–π!', '–î—Ä–∞—Ç—É—Ç–∏']),
                                                              reply_markup=keyboard)

            time.sleep(240)
            bot.delete_message(msg.chat.id, msg.message_id)
        else:
            bot.send_message(message.chat.id, '–î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ —á—ë—Ä–Ω–æ–º —Å–ø–∏—Å–∫–µüòû')
            bot.kick_chat_member(message.chat.id, user.id)


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^Kick\s.+\s.+$', call.data))
def code_callback_query(call):
    bot.answer_callback_query(call.id, '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∫–∏–∫–Ω—É—Çü•ä')
    kick(call.message, call.data.split()[1], call.data.split()[2])


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^Ban\s.+\s.+$', call.data))
def code_callback_query(call):
    bot.answer_callback_query(call.id, '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–∞–Ω–µ–Ω –Ω–∞–≤—Å–µ–≥–¥–∞üòØ')
    ban(call.message, call.data.split()[1], call.data.split()[2])


@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^Mute\s.+\s.+$', call.data))
def code_callback_query(call):
    bot.answer_callback_query(call.id, '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–º—É—á–µ–Ω –Ω–∞ 30 –º–∏–Ω—É—Çü§ê')
    mute(call.message, 30, call.data.split()[1], call.data.split()[2])


@bot.message_handler(content_types=['left_chat_member'])
def left_member_handler(message: Message) -> None:
    bot.send_message(message.chat.id, random.choice(['–°–ª–∏–ª—Å—è –ø–∞–¥–ª–æ(', '–ë—É–µ–Ω–æ—Å –º—É—á–∞—á–µ—Å –ø–∏–¥—Ä–∏–ª–∞—Å', '–ü—Ä–æ—â–∞–π –ª—é–±–æ–≤—å –º–æ—è',
                                                     '–ê—Ä–∏–≤–∏–¥–µ—Ä—á–∏', '–°–ª–∞–≤–∞ –±–æ–≥—É –æ–Ω —É—à–µ–ª',
                                                     '–ë–µ–∑ –Ω–µ–≥–æ —Ç—É—Ç –±—É–¥–µ—Ç –∫—É–¥–∞ –ø—Ä–∏—è—Ç–Ω–µ–µ',
                                                     '–ù—É, —Ç–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –Ω–∞—á–∏–Ω–∞—Ç—å –≤–µ—Å–∏–ª–∏—Ç—Å—è', '–û–Ω –±—ã–ª —Ç–∞–∫–æ–π –¥—É—à–Ω—ã–π',
                                                     '–≠—Ç–æ –ø–æ–π–¥–µ—Ç –≤—Å–µ–º –Ω–∞ –ø–æ–ª—å–∑—É', '–ß—Ç–æ –Ω–µ –¥–µ–ª–∞–µ—Ç—Å—è –≤—Å–µ –∫ –ª—É—á—à–µ–º—É']))


@bot.message_handler(content_types=['voice'])  # Answer on voice
def voice_handler(message: Message) -> None:
    if message.chat.type != 'private':
        db.change_karma(message.from_user.id, '+', 1)
    settings = db.get_from(message.chat.id, 'Setting')
    if settings['recognize'] != 'Off':
        r = sr.Recognizer()
        data = request.urlopen(bot.get_file_url(message.voice.file_id)).read()
        with tempfile.NamedTemporaryFile(delete=False) as f:
            f.write(data)
        audio = AudioSegment.from_ogg(f.name)
        audio.export(f'file.wav', format='wav')
        file = sr.AudioFile('file.wav')
        with file as source:
            audio = r.record(source)
        try:
            if settings['recognize'] == 'Wix':
                rec = r.recognize_wit(audio, key=API['Wit'])
                rec = rec[0].title() + rec[1:]
            else:
                setting = db.get_from(message.chat.id, 'Setting')
                rec = r.recognize_google(audio,
                        language=f"{'ru-RU' if setting['leng_speak'] == 'Ru' else 'uk-UA' if setting['leng_speak'] == 'Ua' else 'en-US'}")
                rec = rec[0].title() + rec[1:]
        except (sr.UnknownValueError, sr.RequestError):
            log(f"Could not request results from Wit Recognition service", 'warning')
            bot.send_message(message.chat.id, '–ù–µ —Å–º–æ–≥ —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≥–æ–ª–æ—Åüòû')
        else:
            send_text(message, rec)


def send_text(message: Message, rec: str) -> None:
    keyboard = InlineKeyboardMarkup()
    if message.forward_from is None:
        if message.from_user.first_name is not None:
            user = message.from_user.first_name
            if message.from_user.last_name is not None:
                user += ' ' + message.from_user.last_name
        else:
            user = message.from_user.username
    else:
        if message.forward_from.first_name is not None:
            user = message.forward_from.first_name
            if message.forward_from.last_name is not None:
                user += ' ' + message.forward_from.last_name
        else:
            user = message.forward_from.username
    msg = bot.reply_to(message, f'–û—Ç <b><i>{user}</i></b>\n{rec}')
    keyboard.add(InlineKeyboardButton('–£–¥–∞–ª–∏—Ç—å', callback_data=f'del {msg.message_id}'))
    bot.edit_message_text(msg.text, msg.chat.id, msg.message_id, reply_markup=keyboard, parse_mode='HTML')
    try:
        os.remove(os.path.join(os.path.abspath(os.path.dirname(__file__)), f'file.wav'))
    except (FileNotFoundError, NameError):
        log('Error! Can\'t remove file', 'warning')


@bot.message_handler(content_types=['photo'])
def photo_handler(message: Message) -> None:
    if message.chat.type != 'private':
        db.change_karma(message.from_user.id, '+', 1)


@bot.message_handler(content_types=['location'])  # Answer on location
def location_handler(message: Message) -> None:
    if message.chat.type != 'private':
        db.change_karma(message.from_user.id, '+', 1)
        if rend_d(30):
            bot.reply_to(message, ['–°–∫–∏–Ω—É–ª –º—É—Å–æ—Ä–∞–º', '–ü—Ä–∏–∫–æ–ø –∏–ª–∏ –º–∞–≥–Ω–∏—Ç?', '–ï–±–µ–Ω—è –∫–∞–∫–∏–µ —Ç–æ',
                                   '–¢–∞ –Ω—É –Ω–∞—Ñ–∏–≥, —è —Ç—É–¥–∞ –Ω–µ –ø–æ–µ–¥—É', '–≠—Ç–æ —Ç—ã —Ç–∞–º –∂–∏–≤–µ—à—å? –°–æ—á—É–≤—Å—Ç–≤—É—é',
                                   '–û–π –Ω—É –∏ –º–µ—Å—Ç–µ—á–∫–æ –¥–ª—è —Å—Ö–æ–¥–æ—á–∫–∏ –≤—ã –≤—ã–±—Ä–∞–ª–∏...',
                                   '–Ø –±—ã —Ç—É–¥–∞ –Ω–µ –ø–æ–µ—Ö–∞–ª –±—É–¥—å —è –¥–∞–∂–µ –ø—å—è–Ω',
                                   '–î–µ–±—Ä–∏', '–¢–∞–∫ —Ç–∞–∫, –≤–∏–∂—É —Å—Ç–µ–ø–∏ –∏ –±–æ–ª–æ—Ç–æ'])


@bot.message_handler(content_types=['contact'])  # Answer on contact
def contact_handler(message: Message) -> None:
    if message.chat.type != 'private':
        db.change_karma(message.from_user.id, '+', 1)
        if rend_d(30):
            bot.reply_to(message, random.choice(['–ï—Å–ª–∏ –º–Ω–µ –±—É–¥–µ—Ç –æ–¥–∏–Ω–æ–∫–æ –∏ —Ö–æ–ª–æ–¥–Ω–æ —è –∑–Ω–∞—é –∫—É–¥–∞ –ø–æ–∑–≤–æ–Ω–∏—Ç—å',
                                                         '–¢—Ä—É–±–∫—É –Ω–µ –±–µ—Ä—É—Ç', '–°–æ—Ö—Ä–∞–Ω–∏–ª', '–ê –º–æ–π –∑–∞–ø–∏—à–µ—à—å?',
                                                         '–ù–∞–±–µ—Ä—É —Ç–µ–±—è –≤–µ—á–µ—Ä–∫–æ–º)', '–†–∞–∑–æ—à–ª—é –µ–≥–æ –≤—Å–µ–º –∑–Ω–∞–∫–æ–º—ã–º',
                                                         '–ü—Ä–æ–¥–∞–º –≤ DarkNet']))

# <<< End answer's  >>>


# <<< Unpin bad guys and casino messages  >>>
@bot.message_handler(content_types=['pinned_message'])
def pin_handler(message: Message) -> None:
    try:
        if message.pinned_message.json['text'].startswith('üéâ–ü–∏–¥–æ—Ä') or message.pinned_message.json['text'].startswith('–î–æ–±—Ä–æ'):
            bot.delete_message(message.chat.id, message.message_id)
    except Exception:
        log('Key error in unpin bad gay', 'error')

# <<< End unpin bad guys message  >>>


# <<< Del  >>>
@bot.callback_query_handler(func=lambda call: re.fullmatch(r'^del\s.+$', call.data))
def del_query(call):
    bot.answer_callback_query(call.id, '–£–¥–∞–ª–µ–Ω–æ')
    for i in call.data.split()[1:]:
        try:
            bot.delete_message(call.message.chat.id, i)
        except Exception:
            log(f'Can\'t delete message', 'warning')



# <<< End del  >>>


#<<< Pass >>>
@bot.callback_query_handler(func=lambda call: re.match(r'\w+_move_to\spass', call.data))
def pass_query(call):
    bot.answer_callback_query(call.id, '‚õîÔ∏è')


# <<< End pass  >>>


# <<< Bot polling  >>>
try:
    bot.polling(none_stop=True)
except Exception as ex:
    log('Bot polling error', 'error')
    time.sleep(15)

# <<< End bot polling  >>>
